<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Editor: LodePNG.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>LodePNG.h</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">LodePNG version 20101211</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">Copyright (c) 2005-2010 Lode Vandevenne</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">This software is provided &#39;as-is&#39;, without any express or implied</span>
<a name="l00007"></a>00007 <span class="comment">warranty. In no event will the authors be held liable for any damages</span>
<a name="l00008"></a>00008 <span class="comment">arising from the use of this software.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00011"></a>00011 <span class="comment">including commercial applications, and to alter it and redistribute it</span>
<a name="l00012"></a>00012 <span class="comment">freely, subject to the following restrictions:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    1. The origin of this software must not be misrepresented; you must not</span>
<a name="l00015"></a>00015 <span class="comment">    claim that you wrote the original software. If you use this software</span>
<a name="l00016"></a>00016 <span class="comment">    in a product, an acknowledgment in the product documentation would be</span>
<a name="l00017"></a>00017 <span class="comment">    appreciated but is not required.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">    2. Altered source versions must be plainly marked as such, and must not be</span>
<a name="l00020"></a>00020 <span class="comment">    misrepresented as being the original software.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">    3. This notice may not be removed or altered from any source</span>
<a name="l00023"></a>00023 <span class="comment">    distribution.</span>
<a name="l00024"></a>00024 <span class="comment">*/</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef LODEPNG_H</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define LODEPNG_H</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#endif </span><span class="comment">/*__cplusplus*/</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00035"></a>00035 <span class="comment">/* Code Sections                                                              */</span>
<a name="l00036"></a>00036 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="comment">/*</span>
<a name="l00039"></a>00039 <span class="comment">The following #defines are used to create code sections. They can be disabled</span>
<a name="l00040"></a>00040 <span class="comment">to disable code sections, which can give faster compile time and smaller binary.</span>
<a name="l00041"></a>00041 <span class="comment">Also, some text editors allow expanding/collapsing #ifdef sections.</span>
<a name="l00042"></a>00042 <span class="comment">*/</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#define LODEPNG_COMPILE_ZLIB             </span><span class="comment">/*deflate&amp;zlib encoder and deflate&amp;zlib decoder*/</span>
<a name="l00045"></a>00045 <span class="preprocessor">#define LODEPNG_COMPILE_PNG              </span><span class="comment">/*png encoder and png decoder*/</span>
<a name="l00046"></a>00046 <span class="preprocessor">#define LODEPNG_COMPILE_DECODER          </span><span class="comment">/*deflate&amp;zlib decoder and png decoder*/</span>
<a name="l00047"></a>00047 <span class="preprocessor">#define LODEPNG_COMPILE_ENCODER          </span><span class="comment">/*deflate&amp;zlib encoder and png encoder*/</span>
<a name="l00048"></a>00048 <span class="preprocessor">#define LODEPNG_COMPILE_DISK             </span><span class="comment">/*the optional built in harddisk file loading and saving functions*/</span>
<a name="l00049"></a>00049 <span class="preprocessor">#define LODEPNG_COMPILE_ANCILLARY_CHUNKS </span><span class="comment">/*any code or struct datamember related to chunks other than IHDR, IDAT, PLTE, tRNS, IEND*/</span>
<a name="l00050"></a>00050 <span class="preprocessor">#define LODEPNG_COMPILE_UNKNOWN_CHUNKS   </span><span class="comment">/*handling of unknown chunks*/</span>
<a name="l00051"></a>00051 <span class="preprocessor">#define LODEPNG_COMPILE_ERROR_TEXT       </span><span class="comment">/*ability to convert error numerical codes to English text string*/</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00054"></a>00054 <span class="comment">/* Simple Functions                                                           */</span>
<a name="l00055"></a>00055 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">/*</span>
<a name="l00058"></a>00058 <span class="comment">This are the simple functions, they can be used directly to convert raw data</span>
<a name="l00059"></a>00059 <span class="comment">to/from PNG data. Both the C and C++ simple functions are declared here.</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">If more flexibility and settings are required, then the more advanced interface</span>
<a name="l00062"></a>00062 <span class="comment">below this &quot;simple&quot; part has to be used.</span>
<a name="l00063"></a>00063 <span class="comment">*/</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="preprocessor">#ifdef LODEPNG_COMPILE_PNG</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="comment">/*</span>
<a name="l00069"></a>00069 <span class="comment">LodePNG_decode</span>
<a name="l00070"></a>00070 <span class="comment">Converts PNG data in memory to raw pixel data.</span>
<a name="l00071"></a>00071 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00072"></a>00072 <span class="comment">     Its size is w * h * (bytes per pixel), bytes per pixel depends on colorType and bitDepth.</span>
<a name="l00073"></a>00073 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00074"></a>00074 <span class="comment">w: Output parameter. Pointer to width of pixel data.</span>
<a name="l00075"></a>00075 <span class="comment">h: Output parameter. Pointer to height of pixel data.</span>
<a name="l00076"></a>00076 <span class="comment">in: Memory buffer with the PNG file.</span>
<a name="l00077"></a>00077 <span class="comment">insize: size of the in buffer.</span>
<a name="l00078"></a>00078 <span class="comment">colorType: the desired color type for the raw output image. See explanation on PNG color types.</span>
<a name="l00079"></a>00079 <span class="comment">bitDepth: the desired bit depth for the raw output image. See explanation on PNG color types.</span>
<a name="l00080"></a>00080 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00081"></a>00081 <span class="comment">*/</span>
<a name="l00082"></a>00082 <span class="keywordtype">unsigned</span> LodePNG_decode(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">unsigned</span>* w, <span class="keywordtype">unsigned</span>* h, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keywordtype">unsigned</span> colorType, <span class="keywordtype">unsigned</span> bitDepth); <span class="comment">/*return value is error*/</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">/*</span>
<a name="l00085"></a>00085 <span class="comment">LodePNG_decode32</span>
<a name="l00086"></a>00086 <span class="comment">Converts PNG data in memory to 32-bit raw pixel data.</span>
<a name="l00087"></a>00087 <span class="comment">Same as LodePNG_decode, but uses colorType = 6 and bitDepth = 8 by default.</span>
<a name="l00088"></a>00088 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00089"></a>00089 <span class="comment">     Its size is w * h * 4 bytes.</span>
<a name="l00090"></a>00090 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00091"></a>00091 <span class="comment">w: Output parameter. Pointer to width of pixel data.</span>
<a name="l00092"></a>00092 <span class="comment">h: Output parameter. Pointer to height of pixel data.</span>
<a name="l00093"></a>00093 <span class="comment">in: Memory buffer with the PNG file.</span>
<a name="l00094"></a>00094 <span class="comment">insize: size of the in buffer.</span>
<a name="l00095"></a>00095 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00096"></a>00096 <span class="comment">*/</span>
<a name="l00097"></a>00097 <span class="keywordtype">unsigned</span> LodePNG_decode32(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">unsigned</span>* w, <span class="keywordtype">unsigned</span>* h, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize); <span class="comment">/*return value is error*/</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="comment">/*</span>
<a name="l00102"></a>00102 <span class="comment">LodePNG_decode_file</span>
<a name="l00103"></a>00103 <span class="comment">Load PNG from disk, from file with given name.</span>
<a name="l00104"></a>00104 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00105"></a>00105 <span class="comment">     Its size is w * h * (bytes per pixel), bytes per pixel depends on colorType and bitDepth.</span>
<a name="l00106"></a>00106 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00107"></a>00107 <span class="comment">w: Output parameter. Pointer to width of pixel data.</span>
<a name="l00108"></a>00108 <span class="comment">h: Output parameter. Pointer to height of pixel data.</span>
<a name="l00109"></a>00109 <span class="comment">filename: Path on disk of the PNG file.</span>
<a name="l00110"></a>00110 <span class="comment">colorType: the desired color type for the raw output image. See explanation on PNG color types.</span>
<a name="l00111"></a>00111 <span class="comment">bitDepth: the desired bit depth for the raw output image. See explanation on PNG color types.</span>
<a name="l00112"></a>00112 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00113"></a>00113 <span class="comment">*/</span>
<a name="l00114"></a>00114 <span class="keywordtype">unsigned</span> LodePNG_decode_file(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">unsigned</span>* w, <span class="keywordtype">unsigned</span>* h, <span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> colorType, <span class="keywordtype">unsigned</span> bitDepth);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">/*</span>
<a name="l00117"></a>00117 <span class="comment">LodePNG_decode32_file</span>
<a name="l00118"></a>00118 <span class="comment">Load PNG from disk to 32-bit RGBA pixel buffer, from file with given name.</span>
<a name="l00119"></a>00119 <span class="comment">Same as LodePNG_decode_file, but uses colorType = 6 and bitDepth = 8 by default.</span>
<a name="l00120"></a>00120 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00121"></a>00121 <span class="comment">     Its size is w * h * 4 bytes.</span>
<a name="l00122"></a>00122 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00123"></a>00123 <span class="comment">w: Output parameter. Pointer to width of pixel data.</span>
<a name="l00124"></a>00124 <span class="comment">h: Output parameter. Pointer to height of pixel data.</span>
<a name="l00125"></a>00125 <span class="comment">in: Memory buffer with the PNG file.</span>
<a name="l00126"></a>00126 <span class="comment">insize: size of the in buffer.</span>
<a name="l00127"></a>00127 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00128"></a>00128 <span class="comment">*/</span>
<a name="l00129"></a>00129 <span class="keywordtype">unsigned</span> LodePNG_decode32_file(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">unsigned</span>* w, <span class="keywordtype">unsigned</span>* h, <span class="keyword">const</span> <span class="keywordtype">char</span>* filename);
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DISK*/</span>
<a name="l00132"></a>00132 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DECODER*/</span>
<a name="l00133"></a>00133 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="comment">/*</span>
<a name="l00136"></a>00136 <span class="comment">LodePNG_encode</span>
<a name="l00137"></a>00137 <span class="comment">Converts raw pixel data into a PNG image in memory. The colorType and bitDepth</span>
<a name="l00138"></a>00138 <span class="comment">  of the output PNG image cannot be chosen, they are automatically determined</span>
<a name="l00139"></a>00139 <span class="comment">  by the colorType, bitDepth and content of the input pixel data.</span>
<a name="l00140"></a>00140 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00141"></a>00141 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00142"></a>00142 <span class="comment">outsize: Output parameter. Pointer to the size in bytes of the out buffer.</span>
<a name="l00143"></a>00143 <span class="comment">image: The raw pixel data to encode. The size of this buffer should be </span>
<a name="l00144"></a>00144 <span class="comment">       w * h * (bytes per pixel), bytes per pixel depends on colorType and bitDepth.</span>
<a name="l00145"></a>00145 <span class="comment">w: width of the raw pixel data in pixels.</span>
<a name="l00146"></a>00146 <span class="comment">h: height of the raw pixel data in pixels.</span>
<a name="l00147"></a>00147 <span class="comment">colorType: the color type of the raw input image. See explanation on PNG color types.</span>
<a name="l00148"></a>00148 <span class="comment">bitDepth: the bit depth of the raw input image. See explanation on PNG color types.</span>
<a name="l00149"></a>00149 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00150"></a>00150 <span class="comment">*/</span>
<a name="l00151"></a>00151 <span class="keywordtype">unsigned</span> LodePNG_encode(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType, <span class="keywordtype">unsigned</span> bitDepth); <span class="comment">/*return value is error*/</span>
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/*</span>
<a name="l00154"></a>00154 <span class="comment">LodePNG_encode32</span>
<a name="l00155"></a>00155 <span class="comment">Converts 32-bit RGBA raw pixel data into a PNG image in memory.</span>
<a name="l00156"></a>00156 <span class="comment">Same as LodePNG_encode, but uses colorType = 6 and bitDepth = 8 by default.</span>
<a name="l00157"></a>00157 <span class="comment">out: Output parameter. Pointer to buffer that will contain the raw pixel data.</span>
<a name="l00158"></a>00158 <span class="comment">     Must be freed after usage with free(*out).</span>
<a name="l00159"></a>00159 <span class="comment">outsize: Output parameter. Pointer to the size in bytes of the out buffer.</span>
<a name="l00160"></a>00160 <span class="comment">image: The raw pixel data to encode. The size of this buffer should be  w * h * 4 bytes.</span>
<a name="l00161"></a>00161 <span class="comment">w: width of the raw pixel data in pixels.</span>
<a name="l00162"></a>00162 <span class="comment">h: height of the raw pixel data in pixels.</span>
<a name="l00163"></a>00163 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00164"></a>00164 <span class="comment">*/</span>
<a name="l00165"></a>00165 <span class="keywordtype">unsigned</span> LodePNG_encode32(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h); <span class="comment">/*return value is error*/</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>
<a name="l00169"></a>00169 <span class="comment">/*</span>
<a name="l00170"></a>00170 <span class="comment">LodePNG_encode_file</span>
<a name="l00171"></a>00171 <span class="comment">Converts raw pixel data into a PNG file on disk. Same as LodePNG_encode, but</span>
<a name="l00172"></a>00172 <span class="comment">outputs to disk instead of memory buffer.</span>
<a name="l00173"></a>00173 <span class="comment">filename: path to file on disk to write the PNG image to.</span>
<a name="l00174"></a>00174 <span class="comment">image: The raw pixel data to encode. The size of this buffer should be </span>
<a name="l00175"></a>00175 <span class="comment">       w * h * (bytes per pixel), bytes per pixel depends on colorType and bitDepth.</span>
<a name="l00176"></a>00176 <span class="comment">w: width of the raw pixel data in pixels.</span>
<a name="l00177"></a>00177 <span class="comment">h: height of the raw pixel data in pixels.</span>
<a name="l00178"></a>00178 <span class="comment">colorType: the color type of the raw input image. See explanation on PNG color types.</span>
<a name="l00179"></a>00179 <span class="comment">bitDepth: the bit depth of the raw input image. See explanation on PNG color types.</span>
<a name="l00180"></a>00180 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00181"></a>00181 <span class="comment">*/</span>
<a name="l00182"></a>00182 <span class="keywordtype">unsigned</span> LodePNG_encode_file(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType, <span class="keywordtype">unsigned</span> bitDepth);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/*</span>
<a name="l00185"></a>00185 <span class="comment">LodePNG_encode_file</span>
<a name="l00186"></a>00186 <span class="comment">Converts 32-bit RGBA raw pixel data into a PNG file on disk. Same as LodePNG_encode_file,</span>
<a name="l00187"></a>00187 <span class="comment">but uses colorType = 6 and bitDepth = 8 by default.</span>
<a name="l00188"></a>00188 <span class="comment">filename: path to file on disk to write the PNG image to.</span>
<a name="l00189"></a>00189 <span class="comment">image: The raw pixel data to encode. The size of this buffer should be w * h * 4 bytes.</span>
<a name="l00190"></a>00190 <span class="comment">w: width of the raw pixel data in pixels.</span>
<a name="l00191"></a>00191 <span class="comment">h: height of the raw pixel data in pixels.</span>
<a name="l00192"></a>00192 <span class="comment">Return value: LodePNG error code (0 means no error).</span>
<a name="l00193"></a>00193 <span class="comment">*/</span>
<a name="l00194"></a>00194 <span class="keywordtype">unsigned</span> LodePNG_encode32_file(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h);
<a name="l00195"></a>00195 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DISK*/</span>
<a name="l00196"></a>00196 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ENCODER*/</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="keyword">namespace </span>LodePNG
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>  
<a name="l00204"></a>00204   <span class="comment">/*</span>
<a name="l00205"></a>00205 <span class="comment">  LodePNG::decode</span>
<a name="l00206"></a>00206 <span class="comment">  Converts PNG data in memory to raw pixel data.</span>
<a name="l00207"></a>00207 <span class="comment">  out: Output parameter, std::vector containing the raw pixel data. Its size</span>
<a name="l00208"></a>00208 <span class="comment">    will be w * h * (bytes per pixel), where bytes per pixel is 4 if the default</span>
<a name="l00209"></a>00209 <span class="comment">    colorType=6 and bitDepth=8 is used. The pixels are 32-bit RGBA bit in that case.</span>
<a name="l00210"></a>00210 <span class="comment">  w: Output parameter, width of the image in pixels.</span>
<a name="l00211"></a>00211 <span class="comment">  h: Output parameter, height of the image in pixels.</span>
<a name="l00212"></a>00212 <span class="comment">  in: Memory buffer with the PNG file.</span>
<a name="l00213"></a>00213 <span class="comment">  insize: size of the in buffer.</span>
<a name="l00214"></a>00214 <span class="comment">  colorType: the desired color type for the raw output image. See explanation on PNG color types.</span>
<a name="l00215"></a>00215 <span class="comment">  bitDepth: the desired bit depth for the raw output image. See explanation on PNG color types.</span>
<a name="l00216"></a>00216 <span class="comment">  Return value: LodePNG error code (0 means no error).</span>
<a name="l00217"></a>00217 <span class="comment">  */</span>
<a name="l00218"></a>00218   <span class="keywordtype">unsigned</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keywordtype">unsigned</span>&amp; w, <span class="keywordtype">unsigned</span>&amp; h, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00219"></a>00219   
<a name="l00220"></a>00220   <span class="comment">/*</span>
<a name="l00221"></a>00221 <span class="comment">  LodePNG::decode</span>
<a name="l00222"></a>00222 <span class="comment">  Exactly the same as the decode function that takes a unsigned char buffer, but instead of giving</span>
<a name="l00223"></a>00223 <span class="comment">  a pointer and a size, this takes the input buffer as an std::vector.</span>
<a name="l00224"></a>00224 <span class="comment">  */</span>
<a name="l00225"></a>00225   <span class="keywordtype">unsigned</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keywordtype">unsigned</span>&amp; w, <span class="keywordtype">unsigned</span>&amp; h, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00226"></a>00226 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00228"></a>00228 <span class="comment">  LodePNG::decode</span>
<a name="l00229"></a>00229 <span class="comment">  Converts PNG file from disk to raw pixel data in memory.</span>
<a name="l00230"></a>00230 <span class="comment">  out: Output parameter, std::vector containing the raw pixel data. Its size</span>
<a name="l00231"></a>00231 <span class="comment">    will be w * h * (bytes per pixel), where bytes per pixel is 4 if the default</span>
<a name="l00232"></a>00232 <span class="comment">    colorType=6 and bitDepth=8 is used. The pixels are 32-bit RGBA bit in that case.</span>
<a name="l00233"></a>00233 <span class="comment">  w: Output parameter, width of the image in pixels.</span>
<a name="l00234"></a>00234 <span class="comment">  h: Output parameter, height of the image in pixels.</span>
<a name="l00235"></a>00235 <span class="comment">  filename: Path to PNG file on disk.</span>
<a name="l00236"></a>00236 <span class="comment">  colorType: the desired color type for the raw output image. See explanation on PNG color types.</span>
<a name="l00237"></a>00237 <span class="comment">  bitDepth: the desired bit depth for the raw output image. See explanation on PNG color types.</span>
<a name="l00238"></a>00238 <span class="comment">  Return value: LodePNG error code (0 means no error).</span>
<a name="l00239"></a>00239 <span class="comment">  */</span>
<a name="l00240"></a>00240   <span class="keywordtype">unsigned</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keywordtype">unsigned</span>&amp; w, <span class="keywordtype">unsigned</span>&amp; h, <span class="keyword">const</span> std::string&amp; filename, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00241"></a>00241 <span class="preprocessor">#endif //LODEPNG_COMPILE_DISK</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span><span class="preprocessor">#endif //LODEPNG_COMPILE_DECODER</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span>  
<a name="l00244"></a>00244 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span>  
<a name="l00246"></a>00246   <span class="comment">/*</span>
<a name="l00247"></a>00247 <span class="comment">  LodePNG::encode</span>
<a name="l00248"></a>00248 <span class="comment">  Converts 32-bit RGBA raw pixel data into a PNG image in memory.</span>
<a name="l00249"></a>00249 <span class="comment">  out: Output parameter, std::vector containing the PNG image data.</span>
<a name="l00250"></a>00250 <span class="comment">  in: Memory buffer with raw pixel data. The size of this buffer should be </span>
<a name="l00251"></a>00251 <span class="comment">       w * h * (bytes per pixel), With the default colorType=6 and bitDepth=8, bytes</span>
<a name="l00252"></a>00252 <span class="comment">       per pixel should be 4 and the data is a 32-bit RGBA pixel buffer.</span>
<a name="l00253"></a>00253 <span class="comment">  w: Width of the image in pixels.</span>
<a name="l00254"></a>00254 <span class="comment">  h: Height of the image in pixels.</span>
<a name="l00255"></a>00255 <span class="comment">  colorType: the color type of the raw input image. See explanation on PNG color types.</span>
<a name="l00256"></a>00256 <span class="comment">  bitDepth: the bit depth of the raw input image. See explanation on PNG color types.</span>
<a name="l00257"></a>00257 <span class="comment">  Return value: LodePNG error code (0 means no error).</span>
<a name="l00258"></a>00258 <span class="comment">  */</span>
<a name="l00259"></a>00259   <span class="keywordtype">unsigned</span> encode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00260"></a>00260   
<a name="l00261"></a>00261   <span class="comment">/*</span>
<a name="l00262"></a>00262 <span class="comment">  LodePNG::encode</span>
<a name="l00263"></a>00263 <span class="comment">  Exactly the same as the encode function that takes a unsigned char buffer, but instead of giving</span>
<a name="l00264"></a>00264 <span class="comment">  a pointer and a size, this takes the input buffer as an std::vector.</span>
<a name="l00265"></a>00265 <span class="comment">  */</span>
<a name="l00266"></a>00266   <span class="keywordtype">unsigned</span> encode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00267"></a>00267 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00269"></a>00269 <span class="comment">  LodePNG::encode</span>
<a name="l00270"></a>00270 <span class="comment">  Converts 32-bit RGBA raw pixel data into a PNG file on disk.</span>
<a name="l00271"></a>00271 <span class="comment">  filename: Path to the file to write the PNG image to.</span>
<a name="l00272"></a>00272 <span class="comment">  in: Memory buffer with raw pixel data. The size of this buffer should be </span>
<a name="l00273"></a>00273 <span class="comment">       w * h * (bytes per pixel), With the default colorType=6 and bitDepth=8, bytes</span>
<a name="l00274"></a>00274 <span class="comment">       per pixel should be 4 and the data is a 32-bit RGBA pixel buffer.</span>
<a name="l00275"></a>00275 <span class="comment">  w: Width of the image in pixels.</span>
<a name="l00276"></a>00276 <span class="comment">  h: Height of the image in pixels.</span>
<a name="l00277"></a>00277 <span class="comment">  colorType: the color type of the raw input image. See explanation on PNG color types.</span>
<a name="l00278"></a>00278 <span class="comment">  bitDepth: the bit depth of the raw input image. See explanation on PNG color types.</span>
<a name="l00279"></a>00279 <span class="comment">  Return value: LodePNG error code (0 means no error).</span>
<a name="l00280"></a>00280 <span class="comment">  */</span>
<a name="l00281"></a>00281   <span class="keywordtype">unsigned</span> encode(<span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00282"></a>00282   
<a name="l00283"></a>00283   <span class="comment">/*</span>
<a name="l00284"></a>00284 <span class="comment">  LodePNG::encode</span>
<a name="l00285"></a>00285 <span class="comment">  Exactly the same as the encode function that takes a unsigned char buffer, but instead of giving</span>
<a name="l00286"></a>00286 <span class="comment">  a pointer and a size, this takes the input buffer as an std::vector.</span>
<a name="l00287"></a>00287 <span class="comment">  */</span>
<a name="l00288"></a>00288   <span class="keywordtype">unsigned</span> encode(<span class="keyword">const</span> std::string&amp; filename, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h, <span class="keywordtype">unsigned</span> colorType = 6, <span class="keywordtype">unsigned</span> bitDepth = 8);
<a name="l00289"></a>00289 <span class="preprocessor">#endif //LODEPNG_COMPILE_DISK</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span><span class="preprocessor">#endif //LODEPNG_COMPILE_ENCODER</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>} <span class="comment">//namespace LodePNG</span>
<a name="l00292"></a>00292 <span class="preprocessor">#endif </span><span class="comment">/*__cplusplus*/</span>
<a name="l00293"></a>00293 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_PNG*/</span>
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ERROR_TEXT</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span>
<a name="l00297"></a>00297 <span class="comment">/*</span>
<a name="l00298"></a>00298 <span class="comment">error_text: returns a textual description of the error code, in English. The</span>
<a name="l00299"></a>00299 <span class="comment">numerical value of the code itself is not included in this description.</span>
<a name="l00300"></a>00300 <span class="comment">*/</span>
<a name="l00301"></a>00301 <span class="keyword">const</span> <span class="keywordtype">char</span>* LodePNG_error_text(<span class="keywordtype">unsigned</span> code);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ERROR_TEXT*/</span>
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00306"></a>00306 <span class="comment">/* Inflate &amp; Deflate Setting Structs                                          */</span>
<a name="l00307"></a>00307 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="comment">/*</span>
<a name="l00310"></a>00310 <span class="comment">These structs contain settings for the decompression and compression of the</span>
<a name="l00311"></a>00311 <span class="comment">PNG files. Typically you won&#39;t need these directly.</span>
<a name="l00312"></a>00312 <span class="comment">*/</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00315"></a><a class="code" href="struct_lode_zlib___decompress_settings.html">00315</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317   <span class="keywordtype">unsigned</span> ignoreAdler32; <span class="comment">/*if 1, continue and don&#39;t give an error message if the Adler32 checksum is corrupted*/</span>
<a name="l00318"></a>00318 } <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a> LodeZlib_defaultDecompressSettings;
<a name="l00321"></a>00321 <span class="keywordtype">void</span> LodeZlib_DecompressSettings_init(<a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>* settings);
<a name="l00322"></a>00322 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DECODER*/</span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00326"></a>00326 <span class="comment">LodeZlib_CompressSettings</span>
<a name="l00327"></a>00327 <span class="comment">Compression settings. Tweaking these settings tweaks the balance between</span>
<a name="l00328"></a>00328 <span class="comment">speed and compression ratio.</span>
<a name="l00329"></a>00329 <span class="comment">*/</span>
<a name="l00330"></a><a class="code" href="struct_lode_zlib___compress_settings.html">00330</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a> <span class="comment">/*deflate = compress*/</span>
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332   <span class="comment">/*LZ77 related settings*/</span>
<a name="l00333"></a>00333   <span class="keywordtype">unsigned</span> btype; <span class="comment">/*the block type for LZ (0, 1, 2 or 3, see zlib standard)*/</span>
<a name="l00334"></a>00334   <span class="keywordtype">unsigned</span> useLZ77; <span class="comment">/*whether or not to use LZ77. Should be 1 for good compression.*/</span>
<a name="l00335"></a>00335   <span class="keywordtype">unsigned</span> windowSize; <span class="comment">/*the maximum is 32768, higher gives more compression but is slower*/</span>
<a name="l00336"></a>00336 } <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a>;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a> LodeZlib_defaultCompressSettings;
<a name="l00339"></a>00339 <span class="keywordtype">void</span> LodeZlib_CompressSettings_init(<a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a>* settings);
<a name="l00340"></a>00340 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ENCODER*/</span>
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="preprocessor">#ifdef LODEPNG_COMPILE_PNG</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>
<a name="l00344"></a>00344 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00345"></a>00345 <span class="comment">/* PNG and Raw Image Information Structs                                      */</span>
<a name="l00346"></a>00346 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="comment">/*</span>
<a name="l00349"></a>00349 <span class="comment">LodePNG_InfoColor</span>
<a name="l00350"></a>00350 <span class="comment">Info about the color type of an image.</span>
<a name="l00351"></a>00351 <span class="comment">The same LodePNG_InfoColor struct is used for both the PNG and raw image type,</span>
<a name="l00352"></a>00352 <span class="comment">even though they are two totally different things.</span>
<a name="l00353"></a>00353 <span class="comment">*/</span>
<a name="l00354"></a><a class="code" href="struct_lode_p_n_g___info_color.html">00354</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="comment">/*header (IHDR)*/</span>
<a name="l00357"></a>00357   <span class="keywordtype">unsigned</span> colorType; <span class="comment">/*color type, see PNG standard or documentation further in this header file*/</span>
<a name="l00358"></a>00358   <span class="keywordtype">unsigned</span> bitDepth;  <span class="comment">/*bits per sample, see PNG standard or documentation further in this header file*/</span>
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">/*</span>
<a name="l00361"></a>00361 <span class="comment">  palette (PLTE)</span>
<a name="l00362"></a>00362 <span class="comment">  </span>
<a name="l00363"></a>00363 <span class="comment">  This is a dynamically allocated unsigned char array with the colors of the palette. The value palettesize</span>
<a name="l00364"></a>00364 <span class="comment">  indicates the amount of colors in the palette. The allocated size of the buffer is 4 * palettesize bytes,</span>
<a name="l00365"></a>00365 <span class="comment">  because there are 4 values per color: R, G, B and A. Even if less color channels are used, the palette</span>
<a name="l00366"></a>00366 <span class="comment">  is always in RGBA format, in the order RGBARGBARGBA.....</span>
<a name="l00367"></a>00367 <span class="comment">  </span>
<a name="l00368"></a>00368 <span class="comment">  When encoding a PNG, to store your colors in the palette of the LodePNG_InfoRaw, first use</span>
<a name="l00369"></a>00369 <span class="comment">  LodePNG_InfoColor_clearPalette, then for each color use LodePNG_InfoColor_addPalette.</span>
<a name="l00370"></a>00370 <span class="comment">  In the C++ version the Encoder class also has the above functions available directly in its interface.</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">  The palette information from the tRNS chunk is also already included in this palette vector.</span>
<a name="l00373"></a>00373 <span class="comment"></span>
<a name="l00374"></a>00374 <span class="comment">  If you encode an image with palette, don&#39;t forget that you have to set the alpha channels (A) of the palette</span>
<a name="l00375"></a>00375 <span class="comment">  too, set them to 255 for an opaque palette. If you leave them at zero, the image will be encoded as</span>
<a name="l00376"></a>00376 <span class="comment">  fully invisible. This both for the palette in the infoRaw and the infoPng if the png is to have a palette.</span>
<a name="l00377"></a>00377 <span class="comment">  </span>
<a name="l00378"></a>00378 <span class="comment">  When decoding, by default you can ignore this information, since LodePNG gives the</span>
<a name="l00379"></a>00379 <span class="comment">  raw output as RGBA pixels by default and already fills the palette values in them.</span>
<a name="l00380"></a>00380 <span class="comment">  */</span>
<a name="l00381"></a>00381   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* palette; <span class="comment">/*palette in RGBARGBA... order*/</span>
<a name="l00382"></a>00382   <span class="keywordtype">size_t</span> palettesize; <span class="comment">/*palette size in number of colors (amount of bytes is 4 * palettesize)*/</span>
<a name="l00383"></a>00383   
<a name="l00384"></a>00384   <span class="comment">/*</span>
<a name="l00385"></a>00385 <span class="comment">  transparent color key (tRNS)</span>
<a name="l00386"></a>00386 <span class="comment">  This color is 8-bit for 8-bit PNGs, 16-bit for 16-bit per channel PNGs.</span>
<a name="l00387"></a>00387 <span class="comment">  For greyscale PNGs, r, g and b will all 3 be set to the same.</span>
<a name="l00388"></a>00388 <span class="comment">  </span>
<a name="l00389"></a>00389 <span class="comment">  When decoding, by default you can ignore this information, since LodePNG sets</span>
<a name="l00390"></a>00390 <span class="comment">  pixels with this key to transparent already in the raw RGBA output.</span>
<a name="l00391"></a>00391 <span class="comment">  */</span>
<a name="l00392"></a>00392   <span class="keywordtype">unsigned</span> key_defined; <span class="comment">/*is a transparent color key given? 0 = false, 1 = true*/</span>
<a name="l00393"></a>00393   <span class="keywordtype">unsigned</span> key_r;       <span class="comment">/*red/greyscale component of color key*/</span>
<a name="l00394"></a>00394   <span class="keywordtype">unsigned</span> key_g;       <span class="comment">/*green component of color key*/</span>
<a name="l00395"></a>00395   <span class="keywordtype">unsigned</span> key_b;       <span class="comment">/*blue component of color key*/</span>
<a name="l00396"></a>00396 } <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00399"></a>00399 <span class="keywordtype">void</span> LodePNG_InfoColor_init(<a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);
<a name="l00400"></a>00400 <span class="keywordtype">void</span> LodePNG_InfoColor_cleanup(<a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);
<a name="l00401"></a>00401 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_copy(<a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* source); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment">/*Use these functions instead of allocating palette manually*/</span>
<a name="l00404"></a>00404 <span class="keywordtype">void</span> LodePNG_InfoColor_clearPalette(<a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);
<a name="l00405"></a>00405 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_addPalette(<a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> a); <span class="comment">/*add 1 color to the palette*/</span>
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="comment">/*additional color info*/</span>
<a name="l00408"></a>00408 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_getBpp(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);      <span class="comment">/*get the total amount of bits per pixel, based on colorType and bitDepth in the struct*/</span>
<a name="l00409"></a>00409 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_getChannels(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info); <span class="comment">/*get the amount of color channels used, based on colorType in the struct. If a palette is used, it counts as 1 channel.*/</span>
<a name="l00410"></a>00410 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_isGreyscaleType(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info); <span class="comment">/*is it a greyscale type? (only colorType 0 or 4)*/</span>
<a name="l00411"></a>00411 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_isAlphaType(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);     <span class="comment">/*has it got an alpha channel? (only colorType 2 or 6)*/</span>
<a name="l00412"></a>00412 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_isPaletteType(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);   <span class="comment">/*has it got a palette? (only colorType 3)*/</span>
<a name="l00413"></a>00413 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_hasPaletteAlpha(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info); <span class="comment">/*only returns true if there is a palette and there is a value in the palette with alpha &lt; 255. Loops through the palette to check this.*/</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="comment">/*</span>
<a name="l00416"></a>00416 <span class="comment">LodePNG_InfoColor_canHaveAlpha</span>
<a name="l00417"></a>00417 <span class="comment">Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.</span>
<a name="l00418"></a>00418 <span class="comment">Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn&#39;t use such pixels).</span>
<a name="l00419"></a>00419 <span class="comment">Returns false if the image can only have opaque pixels.</span>
<a name="l00420"></a>00420 <span class="comment">In detail, it returns true only if it&#39;s a color type with alpha, or has a palette with non-opaque values, or if &quot;key_defined&quot; is true.</span>
<a name="l00421"></a>00421 <span class="comment">*/</span>
<a name="l00422"></a>00422 <span class="keywordtype">unsigned</span> LodePNG_InfoColor_canHaveAlpha(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* info);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00426"></a>00426 <span class="comment">LodePNG_Time</span>
<a name="l00427"></a>00427 <span class="comment">The information of a Time chunk in PNG.</span>
<a name="l00428"></a>00428 <span class="comment">To make the encoder add a time chunk, set time_defined to 1 and fill in</span>
<a name="l00429"></a>00429 <span class="comment">the correct values in all the time parameters. LodePNG will not fill the current</span>
<a name="l00430"></a>00430 <span class="comment">time in these values itself, all it does is copy them over into the chunk bytes.</span>
<a name="l00431"></a>00431 <span class="comment">*/</span>
<a name="l00432"></a><a class="code" href="struct_lode_p_n_g___time.html">00432</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___time.html">LodePNG_Time</a>
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434   <span class="keywordtype">unsigned</span>      year;    <span class="comment">/*2 bytes used (0-65535)*/</span>
<a name="l00435"></a>00435   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> month;   <span class="comment">/*1-12*/</span>
<a name="l00436"></a>00436   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> day;     <span class="comment">/*1-31*/</span>
<a name="l00437"></a>00437   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hour;    <span class="comment">/*0-23*/</span>
<a name="l00438"></a>00438   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> minute;  <span class="comment">/*0-59*/</span>
<a name="l00439"></a>00439   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> second;  <span class="comment">/*0-60 (to allow for leap seconds)*/</span>
<a name="l00440"></a>00440 } <a class="code" href="struct_lode_p_n_g___time.html">LodePNG_Time</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">LodePNG_Text</span>
<a name="l00444"></a>00444 <span class="comment">Info about text chunks in a PNG file. The arrays can contain multiple keys</span>
<a name="l00445"></a>00445 <span class="comment">and strings. The amount of keys and strings is the same. The amount of strings</span>
<a name="l00446"></a>00446 <span class="comment">ends when the pointer to the string is a null pointer.</span>
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">They keyword of text chunks gives a short description what the actual text</span>
<a name="l00449"></a>00449 <span class="comment">represents. There are a few standard standard keywords recognised</span>
<a name="l00450"></a>00450 <span class="comment">by many programs: Title, Author, Description, Copyright, Creation Time,</span>
<a name="l00451"></a>00451 <span class="comment">Software, Disclaimer, Warning, Source, Comment. It&#39;s allowed to use other keys.</span>
<a name="l00452"></a>00452 <span class="comment"></span>
<a name="l00453"></a>00453 <span class="comment">A keyword is minimum 1 character and maximum 79 characters long. It&#39;s</span>
<a name="l00454"></a>00454 <span class="comment">discouraged to use a single line length longer than 79 characters for texts.</span>
<a name="l00455"></a>00455 <span class="comment">*/</span>
<a name="l00456"></a><a class="code" href="struct_lode_p_n_g___text.html">00456</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a> <span class="comment">/*non-international text*/</span>
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458   <span class="comment">/*Don&#39;t allocate these text buffers yourself. Use the init/cleanup functions</span>
<a name="l00459"></a>00459 <span class="comment">  correctly and use LodePNG_Text_add and LodePNG_Text_clear.*/</span>
<a name="l00460"></a>00460   <span class="keywordtype">size_t</span> num; <span class="comment">/*the amount of texts in these char** buffers (there may be more texts in itext)*/</span>
<a name="l00461"></a>00461   <span class="keywordtype">char</span>** keys; <span class="comment">/*the keyword of a text chunk (e.g. &quot;Comment&quot;)*/</span>
<a name="l00462"></a>00462   <span class="keywordtype">char</span>** strings; <span class="comment">/*the actual text*/</span>
<a name="l00463"></a>00463 } <a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00466"></a>00466 <span class="keywordtype">void</span> LodePNG_Text_init(<a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* text);
<a name="l00467"></a>00467 <span class="keywordtype">void</span> LodePNG_Text_cleanup(<a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* text);
<a name="l00468"></a>00468 <span class="keywordtype">unsigned</span> LodePNG_Text_copy(<a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* source); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="comment">/*Use these functions instead of allocating the char**s manually*/</span>
<a name="l00471"></a>00471 <span class="keywordtype">void</span> LodePNG_Text_clear(<a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* text); <span class="comment">/*use this to clear the texts again after you filled them in*/</span>
<a name="l00472"></a>00472 <span class="keywordtype">unsigned</span> LodePNG_Text_add(<a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a>* text, <span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* str); <span class="comment">/*push back both texts at once*/</span>
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="comment">/*</span>
<a name="l00475"></a>00475 <span class="comment">LodePNG_IText</span>
<a name="l00476"></a>00476 <span class="comment">Info about international text chunks in a PNG file. The arrays can contain multiple keys</span>
<a name="l00477"></a>00477 <span class="comment">and strings. The amount of keys, lengtags, transkeys and strings is the same.</span>
<a name="l00478"></a>00478 <span class="comment">The amount of strings ends when the pointer to the string is a null pointer.</span>
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a>00480 <span class="comment">A keyword is minimum 1 character and maximum 79 characters long. It&#39;s</span>
<a name="l00481"></a>00481 <span class="comment">discouraged to use a single line length longer than 79 characters for texts.</span>
<a name="l00482"></a>00482 <span class="comment">*/</span>
<a name="l00483"></a><a class="code" href="struct_lode_p_n_g___i_text.html">00483</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a> <span class="comment">/*international text*/</span>
<a name="l00484"></a>00484 {
<a name="l00485"></a>00485   <span class="comment">/*Don&#39;t allocate these text buffers yourself. Use the init/cleanup functions</span>
<a name="l00486"></a>00486 <span class="comment">  correctly and use LodePNG_IText_add and LodePNG_IText_clear.*/</span>
<a name="l00487"></a>00487   <span class="keywordtype">size_t</span> num; <span class="comment">/*the amount of international texts in this PNG*/</span>
<a name="l00488"></a>00488   <span class="keywordtype">char</span>** keys; <span class="comment">/*the English keyword of the text chunk (e.g. &quot;Comment&quot;)*/</span>
<a name="l00489"></a>00489   <span class="keywordtype">char</span>** langtags; <span class="comment">/*the language tag for this text&#39;s international language, ISO/IEC 646 string, e.g. ISO 639 language tag*/</span>
<a name="l00490"></a>00490   <span class="keywordtype">char</span>** transkeys; <span class="comment">/*keyword translated to the international language - UTF-8 string*/</span>
<a name="l00491"></a>00491   <span class="keywordtype">char</span>** strings; <span class="comment">/*the actual international text - UTF-8 string*/</span>
<a name="l00492"></a>00492 } <a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00495"></a>00495 <span class="keywordtype">void</span> LodePNG_IText_init(<a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* text);
<a name="l00496"></a>00496 <span class="keywordtype">void</span> LodePNG_IText_cleanup(<a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* text);
<a name="l00497"></a>00497 <span class="keywordtype">unsigned</span> LodePNG_IText_copy(<a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* source); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">/*Use these functions instead of allocating the char**s manually*/</span>
<a name="l00500"></a>00500 <span class="keywordtype">void</span> LodePNG_IText_clear(<a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* text); <span class="comment">/*use this to clear the itexts again after you filled them in*/</span>
<a name="l00501"></a>00501 <span class="keywordtype">unsigned</span> LodePNG_IText_add(<a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a>* text, <span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* langtag, <span class="keyword">const</span> <span class="keywordtype">char</span>* transkey, <span class="keyword">const</span> <span class="keywordtype">char</span>* str); <span class="comment">/*push back the 4 texts of 1 chunk at once*/</span>
<a name="l00502"></a>00502 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span>
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="preprocessor">#ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00506"></a>00506 <span class="comment">LodePNG_UnknownChunks</span>
<a name="l00507"></a>00507 <span class="comment">Unknown chunks read from the PNG, or extra chunks the user wants to have added</span>
<a name="l00508"></a>00508 <span class="comment">in the encoded PNG.</span>
<a name="l00509"></a>00509 <span class="comment">*/</span>
<a name="l00510"></a><a class="code" href="struct_lode_p_n_g___unknown_chunks.html">00510</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>
<a name="l00511"></a>00511 {
<a name="l00512"></a>00512   <span class="comment">/*There are 3 buffers, one for each position in the PNG where unknown chunks can appear</span>
<a name="l00513"></a>00513 <span class="comment">    each buffer contains all unknown chunks for that position consecutively</span>
<a name="l00514"></a>00514 <span class="comment">    The 3 buffers are the unknown chunks between certain critical chunks:</span>
<a name="l00515"></a>00515 <span class="comment">    0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND</span>
<a name="l00516"></a>00516 <span class="comment">    </span>
<a name="l00517"></a>00517 <span class="comment">    Do not allocate or traverse this data yourself. Use the chunk traversing functions declared</span>
<a name="l00518"></a>00518 <span class="comment">    later, such as LodePNG_chunk_next and LodePNG_append_chunk, to read/write this struct.</span>
<a name="l00519"></a>00519 <span class="comment">    */</span>
<a name="l00520"></a>00520   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data[3];
<a name="l00521"></a>00521   <span class="keywordtype">size_t</span> datasize[3]; <span class="comment">/*size in bytes of the unknown chunks, given for protection*/</span>
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 } <a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00526"></a>00526 <span class="keywordtype">void</span> LodePNG_UnknownChunks_init(<a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>* chunks);
<a name="l00527"></a>00527 <span class="keywordtype">void</span> LodePNG_UnknownChunks_cleanup(<a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>* chunks);
<a name="l00528"></a>00528 <span class="keywordtype">unsigned</span> LodePNG_UnknownChunks_copy(<a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a>* src); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00529"></a>00529 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/</span>
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">/*</span>
<a name="l00532"></a>00532 <span class="comment">LodePNG_InfoPng</span>
<a name="l00533"></a>00533 <span class="comment">Information about the PNG image, except pixels and sometimes except width and height.</span>
<a name="l00534"></a>00534 <span class="comment">*/</span>
<a name="l00535"></a><a class="code" href="struct_lode_p_n_g___info_png.html">00535</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537   <span class="comment">/*header (IHDR), palette (PLTE) and transparency (tRNS)*/</span>
<a name="l00538"></a>00538   
<a name="l00539"></a>00539   <span class="comment">/*</span>
<a name="l00540"></a>00540 <span class="comment">  Note: width and height are only used as information of a decoded PNG image. When encoding one, you don&#39;t have</span>
<a name="l00541"></a>00541 <span class="comment">  to specify width and height in an LodePNG_Info struct, but you give them as parameters of the encode function.</span>
<a name="l00542"></a>00542 <span class="comment">  The rest of the LodePNG_Info struct IS used by the encoder though!</span>
<a name="l00543"></a>00543 <span class="comment">  */</span>
<a name="l00544"></a>00544   <span class="keywordtype">unsigned</span> width;             <span class="comment">/*width of the image in pixels (ignored by encoder, but filled in by decoder)*/</span>
<a name="l00545"></a>00545   <span class="keywordtype">unsigned</span> height;            <span class="comment">/*height of the image in pixels (ignored by encoder, but filled in by decoder)*/</span>
<a name="l00546"></a>00546   <span class="keywordtype">unsigned</span> compressionMethod; <span class="comment">/*compression method of the original file. Always 0.*/</span>
<a name="l00547"></a>00547   <span class="keywordtype">unsigned</span> filterMethod;      <span class="comment">/*filter method of the original file*/</span>
<a name="l00548"></a>00548   <span class="keywordtype">unsigned</span> interlaceMethod;   <span class="comment">/*interlace method of the original file*/</span>
<a name="l00549"></a>00549   <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a> color;    <span class="comment">/*color type and bits, palette and transparency of the PNG file*/</span>
<a name="l00550"></a>00550   
<a name="l00551"></a>00551 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>  
<a name="l00553"></a>00553   <span class="comment">/*</span>
<a name="l00554"></a>00554 <span class="comment">  suggested background color (bKGD)</span>
<a name="l00555"></a>00555 <span class="comment">  This color is 8-bit for 8-bit PNGs, 16-bit for 16-bit PNGs</span>
<a name="l00556"></a>00556 <span class="comment"></span>
<a name="l00557"></a>00557 <span class="comment">  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding</span>
<a name="l00558"></a>00558 <span class="comment">  the encoder writes the red one. For palette PNGs: When decoding, the RGB value</span>
<a name="l00559"></a>00559 <span class="comment">  will be stored, not a palette index. But when encoding, specify the index of</span>
<a name="l00560"></a>00560 <span class="comment">  the palette in background_r, the other two are then ignored.</span>
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">  The decoder does not use this background color to edit the color of pixels.</span>
<a name="l00563"></a>00563 <span class="comment">  */</span>
<a name="l00564"></a>00564   <span class="keywordtype">unsigned</span> background_defined; <span class="comment">/*is a suggested background color given?*/</span>
<a name="l00565"></a>00565   <span class="keywordtype">unsigned</span> background_r;       <span class="comment">/*red component of suggested background color*/</span>
<a name="l00566"></a>00566   <span class="keywordtype">unsigned</span> background_g;       <span class="comment">/*green component of suggested background color*/</span>
<a name="l00567"></a>00567   <span class="keywordtype">unsigned</span> background_b;       <span class="comment">/*blue component of suggested background color*/</span>
<a name="l00568"></a>00568   
<a name="l00569"></a>00569   <span class="comment">/*non-international text chunks (tEXt and zTXt)*/</span>
<a name="l00570"></a>00570   <a class="code" href="struct_lode_p_n_g___text.html">LodePNG_Text</a> text;
<a name="l00571"></a>00571   
<a name="l00572"></a>00572   <span class="comment">/*international text chunks (iTXt)*/</span>
<a name="l00573"></a>00573   <a class="code" href="struct_lode_p_n_g___i_text.html">LodePNG_IText</a> itext;
<a name="l00574"></a>00574   
<a name="l00575"></a>00575   <span class="comment">/*time chunk (tIME)*/</span>
<a name="l00576"></a>00576   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> time_defined; <span class="comment">/*if 0, no tIME chunk was or will be generated in the PNG image*/</span>
<a name="l00577"></a>00577   <a class="code" href="struct_lode_p_n_g___time.html">LodePNG_Time</a> time;
<a name="l00578"></a>00578   
<a name="l00579"></a>00579   <span class="comment">/*phys chunk (pHYs)*/</span>
<a name="l00580"></a>00580   <span class="keywordtype">unsigned</span>      phys_defined; <span class="comment">/*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/</span>
<a name="l00581"></a>00581   <span class="keywordtype">unsigned</span>      phys_x; <span class="comment">/*pixels per unit in x direction*/</span>
<a name="l00582"></a>00582   <span class="keywordtype">unsigned</span>      phys_y; <span class="comment">/*pixels per unit in y direction*/</span>
<a name="l00583"></a>00583   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phys_unit; <span class="comment">/*may be 0 (unknown unit) or 1 (metre)*/</span>
<a name="l00584"></a>00584   
<a name="l00585"></a>00585 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span>
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 <span class="preprocessor">#ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span>  <span class="comment">/*unknown chunks*/</span>
<a name="l00589"></a>00589   <a class="code" href="struct_lode_p_n_g___unknown_chunks.html">LodePNG_UnknownChunks</a> unknown_chunks;
<a name="l00590"></a>00590 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/</span>
<a name="l00591"></a>00591   
<a name="l00592"></a>00592 } <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00595"></a>00595 <span class="keywordtype">void</span> LodePNG_InfoPng_init(<a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>* info);
<a name="l00596"></a>00596 <span class="keywordtype">void</span> LodePNG_InfoPng_cleanup(<a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>* info);
<a name="l00597"></a>00597 <span class="keywordtype">unsigned</span> LodePNG_InfoPng_copy(<a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>* source); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="comment">/*</span>
<a name="l00600"></a>00600 <span class="comment">LodePNG_InfoRaw</span>
<a name="l00601"></a>00601 <span class="comment">Contains user-chosen information about the raw image data, which is independent of the PNG image</span>
<a name="l00602"></a>00602 <span class="comment">With raw images, I mean the image data in the form of the simple raw buffer to which the</span>
<a name="l00603"></a>00603 <span class="comment">compressed PNG data is decoded, or from which a PNG image can be encoded.</span>
<a name="l00604"></a>00604 <span class="comment">*/</span>
<a name="l00605"></a><a class="code" href="struct_lode_p_n_g___info_raw.html">00605</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>
<a name="l00606"></a>00606 {
<a name="l00607"></a>00607   <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a> color; <span class="comment">/*color info of the raw image, note that the same struct as for PNG data is used.*/</span>
<a name="l00608"></a>00608 } <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00611"></a>00611 <span class="keywordtype">void</span> LodePNG_InfoRaw_init(<a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>* info);
<a name="l00612"></a>00612 <span class="keywordtype">void</span> LodePNG_InfoRaw_cleanup(<a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>* info);
<a name="l00613"></a>00613 <span class="keywordtype">unsigned</span> LodePNG_InfoRaw_copy(<a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>* source); <span class="comment">/*return value is error code (0 means no error)*/</span>
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="comment">/*</span>
<a name="l00616"></a>00616 <span class="comment">LodePNG_convert</span>
<a name="l00617"></a>00617 <span class="comment">Converts raw buffer from one color type to another color type, based on</span>
<a name="l00618"></a>00618 <span class="comment">LodePNG_InfoColor structs to describe the input and output color type.</span>
<a name="l00619"></a>00619 <span class="comment">See the reference manual at the end of this header file to see which color conversions are supported.</span>
<a name="l00620"></a>00620 <span class="comment">return value = LodePNG error code (0 if all went ok, an error if the conversion isn&#39;t supported)</span>
<a name="l00621"></a>00621 <span class="comment">The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel</span>
<a name="l00622"></a>00622 <span class="comment">of the output color type (LodePNG_InfoColor_getBpp)</span>
<a name="l00623"></a>00623 <span class="comment">*/</span>
<a name="l00624"></a>00624 <span class="keywordtype">unsigned</span> LodePNG_convert(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* infoOut, <a class="code" href="struct_lode_p_n_g___info_color.html">LodePNG_InfoColor</a>* infoIn, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00627"></a>00627 <span class="preprocessor"></span>
<a name="l00628"></a>00628 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00629"></a>00629 <span class="comment">/* LodePNG Decoder                                                            */</span>
<a name="l00630"></a>00630 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="comment">/*</span>
<a name="l00633"></a>00633 <span class="comment">Settings for the decoder. This contains settings for the PNG and the Zlib</span>
<a name="l00634"></a>00634 <span class="comment">decoder, but not the Info settings from the Info structs.</span>
<a name="l00635"></a>00635 <span class="comment">*/</span>
<a name="l00636"></a><a class="code" href="struct_lode_p_n_g___decode_settings.html">00636</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>
<a name="l00637"></a>00637 {
<a name="l00638"></a>00638   <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a> zlibsettings; <span class="comment">/*in here is the setting to ignore Adler32 checksums*/</span>
<a name="l00639"></a>00639   
<a name="l00640"></a>00640   <span class="keywordtype">unsigned</span> ignoreCrc; <span class="comment">/*ignore CRC checksums*/</span>
<a name="l00641"></a>00641   <span class="keywordtype">unsigned</span> color_convert; <span class="comment">/*whether to convert the PNG to the color type you want. Default: yes*/</span>
<a name="l00642"></a>00642   
<a name="l00643"></a>00643 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> readTextChunks; <span class="comment">/*if false but rememberUnknownChunks is true, they&#39;re stored in the unknown chunks*/</span>
<a name="l00645"></a>00645 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <span class="preprocessor">#ifdef LODEPNG_COMPILE_UNKNOWN_CHUNKS</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> rememberUnknownChunks; <span class="comment">/*store all bytes from unknown chunks in the InfoPng (off by default, useful for a png editor)*/</span>
<a name="l00649"></a>00649 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_UNKNOWN_CHUNKS*/</span>
<a name="l00650"></a>00650 } <a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 <span class="keywordtype">void</span> LodePNG_DecodeSettings_init(<a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>* settings);
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="comment">/*</span>
<a name="l00655"></a>00655 <span class="comment">The LodePNG_Decoder struct has most input and output parameters the decoder uses,</span>
<a name="l00656"></a>00656 <span class="comment">such as the settings, the info of the PNG and the raw data, and the error. Only</span>
<a name="l00657"></a>00657 <span class="comment">the pixel buffer is not contained in this struct.</span>
<a name="l00658"></a>00658 <span class="comment">*/</span>
<a name="l00659"></a><a class="code" href="struct_lode_p_n_g___decoder.html">00659</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661   <a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a> settings; <span class="comment">/*the decoding settings*/</span>
<a name="l00662"></a>00662   <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a> infoRaw; <span class="comment">/*specifies the format in which you would like to get the raw pixel buffer*/</span>
<a name="l00663"></a>00663   <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a> infoPng; <span class="comment">/*info of the PNG image obtained after decoding*/</span>
<a name="l00664"></a>00664   <span class="keywordtype">unsigned</span> error;
<a name="l00665"></a>00665 } <a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00668"></a>00668 <span class="keywordtype">void</span> LodePNG_Decoder_init(<a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* decoder);
<a name="l00669"></a>00669 <span class="keywordtype">void</span> LodePNG_Decoder_cleanup(<a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* decoder);
<a name="l00670"></a>00670 <span class="keywordtype">void</span> LodePNG_Decoder_copy(<a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* source);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="comment">/*</span>
<a name="l00673"></a>00673 <span class="comment">LodePNG_Decoder_decode</span>
<a name="l00674"></a>00674 <span class="comment">Decode based on a LodePNG_Decoder.</span>
<a name="l00675"></a>00675 <span class="comment">This function allocates the out buffer and stores the size in *outsize. This buffer</span>
<a name="l00676"></a>00676 <span class="comment">needs to be freed after usage.</span>
<a name="l00677"></a>00677 <span class="comment">Other information about the PNG file, such as the size, colorType and extra chunks</span>
<a name="l00678"></a>00678 <span class="comment">are stored in the infoPng field of the LodePNG_Decoder.</span>
<a name="l00679"></a>00679 <span class="comment">*/</span>
<a name="l00680"></a>00680 <span class="keywordtype">void</span> LodePNG_Decoder_decode(<a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* decoder, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="comment">/*</span>
<a name="l00683"></a>00683 <span class="comment">LodePNG_Decoder_inspect</span>
<a name="l00684"></a>00684 <span class="comment">Read the PNG header, but not the actual data. This returns only the information</span>
<a name="l00685"></a>00685 <span class="comment">that is in the header chunk of the PNG, such as width, height and color type. The</span>
<a name="l00686"></a>00686 <span class="comment">information is placed in the infoPng field of the LodePNG_Decoder.</span>
<a name="l00687"></a>00687 <span class="comment">*/</span>
<a name="l00688"></a>00688 <span class="keywordtype">void</span> LodePNG_Decoder_inspect(<a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>* decoder, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize); <span class="comment">/*read the png header*/</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DECODER*/</span>
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00694"></a>00694 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00695"></a>00695 <span class="comment">/* LodePNG Encoder                                                            */</span>
<a name="l00696"></a>00696 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="comment">/*</span>
<a name="l00699"></a>00699 <span class="comment">LodePNG_EncodeSettings</span>
<a name="l00700"></a>00700 <span class="comment">Extra settings used by the encoder.</span>
<a name="l00701"></a>00701 <span class="comment">*/</span>
<a name="l00702"></a><a class="code" href="struct_lode_p_n_g___encode_settings.html">00702</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704   <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a> zlibsettings; <span class="comment">/*settings for the zlib encoder, such as window size, ...*/</span>
<a name="l00705"></a>00705   
<a name="l00706"></a>00706   <span class="keywordtype">unsigned</span> autoLeaveOutAlphaChannel; <span class="comment">/*automatically use color type without alpha instead of given one, if given image is opaque*/</span>
<a name="l00707"></a>00707   <span class="keywordtype">unsigned</span> force_palette; <span class="comment">/*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette). If colortype is 3, PLTE is _always_ created.*/</span>
<a name="l00708"></a>00708 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> add_id; <span class="comment">/*add LodePNG version as text chunk*/</span>
<a name="l00710"></a>00710   <span class="keywordtype">unsigned</span> text_compression; <span class="comment">/*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/</span>
<a name="l00711"></a>00711 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/</span>
<a name="l00712"></a>00712 } <a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keywordtype">void</span> LodePNG_EncodeSettings_init(<a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>* settings);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="comment">/*</span>
<a name="l00717"></a>00717 <span class="comment">LodePNG_Encoder</span>
<a name="l00718"></a>00718 <span class="comment">This struct has most input and output parameters the encoder uses,</span>
<a name="l00719"></a>00719 <span class="comment">such as the settings, the info of the PNG and the raw data, and the error. Only</span>
<a name="l00720"></a>00720 <span class="comment">the pixel buffer is not contained in this struct.</span>
<a name="l00721"></a>00721 <span class="comment">*/</span>
<a name="l00722"></a><a class="code" href="struct_lode_p_n_g___encoder.html">00722</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>
<a name="l00723"></a>00723 {
<a name="l00724"></a>00724   <a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a> settings; <span class="comment">/*compression settings of the encoder*/</span>
<a name="l00725"></a>00725   <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a> infoPng; <span class="comment">/*the info specified by the user is not changed by the encoder. The encoder will try to generate a PNG close to the given info.*/</span>
<a name="l00726"></a>00726   <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a> infoRaw; <span class="comment">/*put the properties of the input raw image in here*/</span>
<a name="l00727"></a>00727   <span class="keywordtype">unsigned</span> error; <span class="comment">/*error value filled in if error happened, or 0 if all went ok*/</span>
<a name="l00728"></a>00728 } <a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <span class="comment">/*init, cleanup and copy functions to use with this struct*/</span>
<a name="l00731"></a>00731 <span class="keywordtype">void</span> LodePNG_Encoder_init(<a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>* encoder);
<a name="l00732"></a>00732 <span class="keywordtype">void</span> LodePNG_Encoder_cleanup(<a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>* encoder);
<a name="l00733"></a>00733 <span class="keywordtype">void</span> LodePNG_Encoder_copy(<a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>* dest, <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>* source);
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 <span class="comment">/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/</span>
<a name="l00736"></a>00736 <span class="keywordtype">void</span> LodePNG_Encoder_encode(<a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>* encoder, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ENCODER*/</span>
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00741"></a>00741 <span class="comment">/* Chunk Traversing Utilities                                                 */</span>
<a name="l00742"></a>00742 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="comment">/*</span>
<a name="l00745"></a>00745 <span class="comment">LodePNG_chunk functions:</span>
<a name="l00746"></a>00746 <span class="comment">These functions need as input a large enough amount of allocated memory.</span>
<a name="l00747"></a>00747 <span class="comment">These functions can be used on raw PNG data, but they are exposed in the API</span>
<a name="l00748"></a>00748 <span class="comment">because they are needed if you want to traverse the unknown chunks stored</span>
<a name="l00749"></a>00749 <span class="comment">in the LodePNG_UnknownChunks struct, or add new ones to it.</span>
<a name="l00750"></a>00750 <span class="comment">*/</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 <span class="keywordtype">unsigned</span> LodePNG_chunk_length(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*get the length of the data of the chunk. Total chunk length has 12 bytes more.*/</span>
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="keywordtype">void</span> LodePNG_chunk_type(<span class="keywordtype">char</span> type[5], <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*puts the 4-byte type in null terminated string*/</span>
<a name="l00755"></a>00755 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> LodePNG_chunk_type_equals(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk, <span class="keyword">const</span> <span class="keywordtype">char</span>* type); <span class="comment">/*check if the type is the given type*/</span>
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="comment">/*</span>
<a name="l00758"></a>00758 <span class="comment">These functions get properties of PNG chunks gotten from capitalization of chunk</span>
<a name="l00759"></a>00759 <span class="comment">type name, as defined by the PNG standard.</span>
<a name="l00760"></a>00760 <span class="comment">*/</span>
<a name="l00761"></a>00761 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> LodePNG_chunk_critical(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*0: ancillary chunk, 1: it&#39;s one of the critical chunk types*/</span>
<a name="l00762"></a>00762 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> LodePNG_chunk_private(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*0: public, 1: private*/</span>
<a name="l00763"></a>00763 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> LodePNG_chunk_safetocopy(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy*/</span>
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* LodePNG_chunk_data(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*get pointer to the data of the chunk*/</span>
<a name="l00766"></a>00766 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* LodePNG_chunk_data_const(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*get pointer to the data of the chunk*/</span>
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="keywordtype">unsigned</span> LodePNG_chunk_check_crc(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*returns 0 if the crc is correct, 1 if it&#39;s incorrect*/</span>
<a name="l00769"></a>00769 <span class="keywordtype">void</span> LodePNG_chunk_generate_crc(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk); <span class="comment">/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="comment">/*iterate to next chunks.*/</span>
<a name="l00772"></a>00772 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* LodePNG_chunk_next(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk);
<a name="l00773"></a>00773 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* LodePNG_chunk_next_const(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="comment">/*</span>
<a name="l00776"></a>00776 <span class="comment">LodePNG_append_chunk</span>
<a name="l00777"></a>00777 <span class="comment">Appends chunk to the data in out. The given chunk should already have its chunk header.</span>
<a name="l00778"></a>00778 <span class="comment">The out variable and outlength are updated to reflect the new reallocated buffer.</span>
<a name="l00779"></a>00779 <span class="comment">Returns error code (0 if it went ok)</span>
<a name="l00780"></a>00780 <span class="comment">*/</span>
<a name="l00781"></a>00781 <span class="keywordtype">unsigned</span> LodePNG_append_chunk(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outlength, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* chunk);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment">/*</span>
<a name="l00784"></a>00784 <span class="comment">LodePNG_create_chunk</span>
<a name="l00785"></a>00785 <span class="comment">Appends new chunk to out. The chunk to append is given by giving its length, type</span>
<a name="l00786"></a>00786 <span class="comment">and data separately. The type is a 4-letter string.</span>
<a name="l00787"></a>00787 <span class="comment">The out variable and outlength are updated to reflect the new reallocated buffer.</span>
<a name="l00788"></a>00788 <span class="comment">Returne error code (0 if it went ok)</span>
<a name="l00789"></a>00789 <span class="comment">*/</span>
<a name="l00790"></a>00790 <span class="keywordtype">unsigned</span> LodePNG_create_chunk(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outlength, <span class="keywordtype">unsigned</span> length, <span class="keyword">const</span> <span class="keywordtype">char</span>* type, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data);
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_PNG*/</span>
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ZLIB</span>
<a name="l00795"></a>00795 <span class="preprocessor"></span><span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00796"></a>00796 <span class="comment">/* Zlib encoder and decoder                                                   */</span>
<a name="l00797"></a>00797 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 <span class="comment">/*</span>
<a name="l00800"></a>00800 <span class="comment">This is &quot;LodeZlib&quot;. A C++ wrapper is available further on.</span>
<a name="l00801"></a>00801 <span class="comment"></span>
<a name="l00802"></a>00802 <span class="comment">LodeZlib can be used to zlib compress and decompress a buffer. It cannot be</span>
<a name="l00803"></a>00803 <span class="comment">used to create gzip files however, and it only supports the part of zlib</span>
<a name="l00804"></a>00804 <span class="comment">that is required for PNG, it does not support dictionaries.</span>
<a name="l00805"></a>00805 <span class="comment">*/</span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00808"></a>00808 <span class="preprocessor"></span><span class="comment">/*This function reallocates the out buffer and appends the data.</span>
<a name="l00809"></a>00809 <span class="comment">Either, *out must be NULL and *outsize must be 0, or, *out must be a valid buffer and *outsize its size in bytes.*/</span>
<a name="l00810"></a>00810 <span class="keywordtype">unsigned</span> LodeZlib_decompress(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>* settings);
<a name="l00811"></a>00811 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DECODER*/</span>
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span><span class="comment">/*This function reallocates the out buffer and appends the data.</span>
<a name="l00815"></a>00815 <span class="comment">Either, *out must be NULL and *outsize must be 0, or, *out must be a valid buffer and *outsize its size in bytes.*/</span>
<a name="l00816"></a>00816 <span class="keywordtype">unsigned</span> LodeZlib_compress(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a>* settings);
<a name="l00817"></a>00817 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ENCODER*/</span>
<a name="l00818"></a>00818 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_ZLIB*/</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00822"></a>00822 <span class="comment">LodePNG_loadFile</span>
<a name="l00823"></a>00823 <span class="comment">Load a file from disk into buffer. The function allocates the out buffer, and</span>
<a name="l00824"></a>00824 <span class="comment">after usage you are responsible for freeing it.</span>
<a name="l00825"></a>00825 <span class="comment">out: output parameter, contains pointer to loaded buffer.</span>
<a name="l00826"></a>00826 <span class="comment">outsize: output parameter, size of the allocated out buffer</span>
<a name="l00827"></a>00827 <span class="comment">filename: the path to the file to load</span>
<a name="l00828"></a>00828 <span class="comment">return value: error code (0 means ok)</span>
<a name="l00829"></a>00829 <span class="comment">*/</span>
<a name="l00830"></a>00830 <span class="keywordtype">unsigned</span> LodePNG_loadFile(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** out, <span class="keywordtype">size_t</span>* outsize, <span class="keyword">const</span> <span class="keywordtype">char</span>* filename);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="comment">/*</span>
<a name="l00833"></a>00833 <span class="comment">LodePNG_saveFile</span>
<a name="l00834"></a>00834 <span class="comment">Save a file from buffer to disk. Warning, this function overwrites the file without warning!</span>
<a name="l00835"></a>00835 <span class="comment">buffer: the buffer to write</span>
<a name="l00836"></a>00836 <span class="comment">buffersize: size of the buffer to write</span>
<a name="l00837"></a>00837 <span class="comment">filename: the path to the file to save to</span>
<a name="l00838"></a>00838 <span class="comment">return value: error code (0 means ok)</span>
<a name="l00839"></a>00839 <span class="comment">*/</span>
<a name="l00840"></a>00840 <span class="keywordtype">unsigned</span> LodePNG_saveFile(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer, <span class="keywordtype">size_t</span> buffersize, <span class="keyword">const</span> <span class="keywordtype">char</span>* filename);
<a name="l00841"></a>00841 <span class="preprocessor">#endif </span><span class="comment">/*LODEPNG_COMPILE_DISK*/</span>
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>
<a name="l00845"></a>00845 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00846"></a>00846 <span class="comment">/* LodePNG C++ wrapper                                                        */</span>
<a name="l00847"></a>00847 <span class="comment">/* ////////////////////////////////////////////////////////////////////////// */</span>
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="comment">//The LodePNG C++ wrapper uses classes with handy constructors and destructors</span>
<a name="l00850"></a>00850 <span class="comment">//instead of manual init and cleanup functions, and uses std::vectors instead of</span>
<a name="l00851"></a>00851 <span class="comment">//manually allocated memory buffers.</span>
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ZLIB</span>
<a name="l00854"></a>00854 <span class="preprocessor"></span><span class="comment">//The C++ wrapper for LodeZlib</span>
<a name="l00855"></a>00855 <span class="keyword">namespace </span>LodeZlib
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00858"></a>00858 <span class="preprocessor"></span>
<a name="l00859"></a>00859   <span class="comment">//Zlib-decompress an unsigned char buffer</span>
<a name="l00860"></a>00860   <span class="keywordtype">unsigned</span> decompress(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>&amp; settings = LodeZlib_defaultDecompressSettings);
<a name="l00861"></a>00861   
<a name="l00862"></a>00862   <span class="comment">//Zlib-decompress an std::vector</span>
<a name="l00863"></a>00863   <span class="keywordtype">unsigned</span> decompress(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___decompress_settings.html">LodeZlib_DecompressSettings</a>&amp; settings = LodeZlib_defaultDecompressSettings);
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="preprocessor">#endif //LODEPNG_COMPILE_DECODER</span>
<a name="l00866"></a>00866 <span class="preprocessor"></span><span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span>
<a name="l00868"></a>00868   <span class="comment">//Zlib-compress an unsigned char buffer</span>
<a name="l00869"></a>00869   <span class="keywordtype">unsigned</span> compress(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a>&amp; settings = LodeZlib_defaultCompressSettings);
<a name="l00870"></a>00870   
<a name="l00871"></a>00871   <span class="comment">//Zlib-compress an std::vector</span>
<a name="l00872"></a>00872   <span class="keywordtype">unsigned</span> compress(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in, <span class="keyword">const</span> <a class="code" href="struct_lode_zlib___compress_settings.html">LodeZlib_CompressSettings</a>&amp; settings = LodeZlib_defaultCompressSettings);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 <span class="preprocessor">#endif //LODEPNG_COMPILE_ENCODER</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>}
<a name="l00876"></a>00876 <span class="preprocessor">#endif //LODEPNG_COMPILE_ZLIB</span>
<a name="l00877"></a>00877 <span class="preprocessor"></span>
<a name="l00878"></a>00878 <span class="preprocessor">#ifdef LODEPNG_COMPILE_PNG</span>
<a name="l00879"></a>00879 <span class="preprocessor"></span><span class="keyword">namespace </span>LodePNG
<a name="l00880"></a>00880 {
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DECODER</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00884"></a>00884 <span class="comment">  LodePNG::Decoder</span>
<a name="l00885"></a>00885 <span class="comment">  Class to decode a PNG image. Before decoding, settings can be set and</span>
<a name="l00886"></a>00886 <span class="comment">  after decoding, extra information about the PNG can be retrieved.</span>
<a name="l00887"></a>00887 <span class="comment">  Extends from the C-struct LodePNG_Decoder to add constructors and destructors</span>
<a name="l00888"></a>00888 <span class="comment">  to initialize/cleanup it automatically. Beware, no virtual destructor is used.</span>
<a name="l00889"></a>00889 <span class="comment">  */</span>
<a name="l00890"></a>00890   <span class="keyword">class </span>Decoder : <span class="keyword">public</span> <a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>
<a name="l00891"></a>00891   {
<a name="l00892"></a>00892     <span class="keyword">public</span>:
<a name="l00893"></a>00893     
<a name="l00894"></a>00894     Decoder();
<a name="l00895"></a>00895     ~Decoder();
<a name="l00896"></a>00896     <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___decoder.html">LodePNG_Decoder</a>&amp; other);
<a name="l00897"></a>00897     
<a name="l00898"></a>00898     <span class="comment">//decode PNG buffer to raw out buffer. Width and height can be retrieved with getWidth() and getHeight() and error should be checked with hasError() and getError()</span>
<a name="l00899"></a>00899     <span class="keywordtype">void</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize);
<a name="l00900"></a>00900     
<a name="l00901"></a>00901     <span class="comment">//decode PNG buffer to raw out buffer. Width and height can be retrieved with getWidth() and getHeight() and error should be checked with hasError() and getError()</span>
<a name="l00902"></a>00902     <span class="keywordtype">void</span> decode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in);
<a name="l00903"></a>00903     
<a name="l00904"></a>00904     <span class="comment">//inspect functions: get only the info from the PNG header. The info can then be retrieved with the functions of this class.</span>
<a name="l00905"></a>00905     <span class="keywordtype">void</span> inspect(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in, <span class="keywordtype">size_t</span> insize);
<a name="l00906"></a>00906     
<a name="l00907"></a>00907     <span class="comment">//inspect functions: get only the info from the PNG header. The info can then be retrieved with the functions of this class.</span>
<a name="l00908"></a>00908     <span class="keywordtype">void</span> inspect(<span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; in);
<a name="l00909"></a>00909     
<a name="l00910"></a>00910     <span class="comment">//error checking after decoding</span>
<a name="l00911"></a>00911     <span class="keywordtype">bool</span> hasError() <span class="keyword">const</span>;
<a name="l00912"></a>00912     <span class="keywordtype">unsigned</span> getError() <span class="keyword">const</span>;
<a name="l00913"></a>00913     
<a name="l00914"></a>00914     <span class="comment">//convenient access to some InfoPng parameters after decoding</span>
<a name="l00915"></a>00915     <span class="keywordtype">unsigned</span> getWidth() <span class="keyword">const</span>; <span class="comment">//width of image in pixels</span>
<a name="l00916"></a>00916     <span class="keywordtype">unsigned</span> getHeight() <span class="keyword">const</span>; <span class="comment">//height of image in pixels</span>
<a name="l00917"></a>00917     <span class="keywordtype">unsigned</span> getBpp(); <span class="comment">//bits per pixel</span>
<a name="l00918"></a>00918     <span class="keywordtype">unsigned</span> getChannels(); <span class="comment">//amount of channels</span>
<a name="l00919"></a>00919     <span class="keywordtype">unsigned</span> isGreyscaleType(); <span class="comment">//is it a greyscale type? (colorType 0 or 4)</span>
<a name="l00920"></a>00920     <span class="keywordtype">unsigned</span> isAlphaType(); <span class="comment">//has it an alpha channel? (colorType 2 or 6)</span>
<a name="l00921"></a>00921     
<a name="l00922"></a>00922     <span class="comment">//getters and setters for the decoding settings</span>
<a name="l00923"></a>00923     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>&amp; getSettings() <span class="keyword">const</span>;
<a name="l00924"></a>00924     <a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>&amp; getSettings();
<a name="l00925"></a>00925     <span class="keywordtype">void</span> setSettings(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___decode_settings.html">LodePNG_DecodeSettings</a>&amp; info);
<a name="l00926"></a>00926     
<a name="l00927"></a>00927     <span class="comment">//getters and setters for the PNG image info, after decoding this describes information of the PNG image</span>
<a name="l00928"></a>00928     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; getInfoPng() <span class="keyword">const</span>;
<a name="l00929"></a>00929     <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; getInfoPng();
<a name="l00930"></a>00930     <span class="keywordtype">void</span> setInfoPng(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; info);
<a name="l00931"></a>00931     <span class="keywordtype">void</span> swapInfoPng(<a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; info); <span class="comment">//faster than copying with setInfoPng</span>
<a name="l00932"></a>00932     
<a name="l00933"></a>00933     <span class="comment">//getters and setters for the raw image info, this determines in what format you get the pixel buffer from the decoder</span>
<a name="l00934"></a>00934     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; getInfoRaw() <span class="keyword">const</span>;
<a name="l00935"></a>00935     <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; getInfoRaw();
<a name="l00936"></a>00936     <span class="keywordtype">void</span> setInfoRaw(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; info);
<a name="l00937"></a>00937   };
<a name="l00938"></a>00938   
<a name="l00939"></a>00939 <span class="preprocessor">#endif //LODEPNG_COMPILE_DECODER</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span>  
<a name="l00941"></a>00941 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ENCODER</span>
<a name="l00942"></a>00942 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00943"></a>00943 <span class="comment">  LodePNG::Encoder</span>
<a name="l00944"></a>00944 <span class="comment">  Class to encode a PNG image. Before encoding, settings can be set.</span>
<a name="l00945"></a>00945 <span class="comment">  Extends from the C-struct LodePNG_Enoder to add constructors and destructors</span>
<a name="l00946"></a>00946 <span class="comment">  to initialize/cleanup it automatically. Beware, no virtual destructor is used.</span>
<a name="l00947"></a>00947 <span class="comment">  */</span>
<a name="l00948"></a>00948   <span class="keyword">class </span>Encoder : <span class="keyword">public</span> <a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>
<a name="l00949"></a>00949   {
<a name="l00950"></a>00950     <span class="keyword">public</span>:
<a name="l00951"></a>00951     
<a name="l00952"></a>00952     Encoder();
<a name="l00953"></a>00953     ~Encoder();
<a name="l00954"></a>00954     <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___encoder.html">LodePNG_Encoder</a>&amp; other);
<a name="l00955"></a>00955     
<a name="l00956"></a>00956     <span class="comment">//encoding image to PNG buffer</span>
<a name="l00957"></a>00957     <span class="keywordtype">void</span> encode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h);
<a name="l00958"></a>00958     
<a name="l00959"></a>00959     <span class="comment">//encoding image to PNG buffer</span>
<a name="l00960"></a>00960     <span class="keywordtype">void</span> encode(std::vector&lt;unsigned char&gt;&amp; out, <span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; image, <span class="keywordtype">unsigned</span> w, <span class="keywordtype">unsigned</span> h);
<a name="l00961"></a>00961     
<a name="l00962"></a>00962     <span class="comment">//error checking after decoding</span>
<a name="l00963"></a>00963     <span class="keywordtype">bool</span> hasError() <span class="keyword">const</span>;
<a name="l00964"></a>00964     <span class="keywordtype">unsigned</span> getError() <span class="keyword">const</span>;
<a name="l00965"></a>00965     
<a name="l00966"></a>00966     <span class="comment">//convenient direct access to some parameters of the InfoPng</span>
<a name="l00967"></a>00967     <span class="keywordtype">void</span> clearPalette();
<a name="l00968"></a>00968     <span class="keywordtype">void</span> addPalette(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> a); <span class="comment">//add 1 color to the palette</span>
<a name="l00969"></a>00969 <span class="preprocessor">#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span>    <span class="keywordtype">void</span> clearText();
<a name="l00971"></a>00971     <span class="keywordtype">void</span> addText(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; str); <span class="comment">//push back both texts at once</span>
<a name="l00972"></a>00972     <span class="keywordtype">void</span> clearIText();
<a name="l00973"></a>00973     <span class="keywordtype">void</span> addIText(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; langtag, <span class="keyword">const</span> std::string&amp; transkey, <span class="keyword">const</span> std::string&amp; str);
<a name="l00974"></a>00974 <span class="preprocessor">#endif //LODEPNG_COMPILE_ANCILLARY_CHUNKS</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>    
<a name="l00976"></a>00976     <span class="comment">//getters and setters for the encoding settings</span>
<a name="l00977"></a>00977     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>&amp; getSettings() <span class="keyword">const</span>;
<a name="l00978"></a>00978     <a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>&amp; getSettings();
<a name="l00979"></a>00979     <span class="keywordtype">void</span> setSettings(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___encode_settings.html">LodePNG_EncodeSettings</a>&amp; info);
<a name="l00980"></a>00980     
<a name="l00981"></a>00981     <span class="comment">//getters and setters for the PNG image info, this describes what color type and other settings the resulting PNG should have</span>
<a name="l00982"></a>00982     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; getInfoPng() <span class="keyword">const</span>;
<a name="l00983"></a>00983     <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; getInfoPng();
<a name="l00984"></a>00984     <span class="keywordtype">void</span> setInfoPng(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; info);
<a name="l00985"></a>00985     <span class="keywordtype">void</span> swapInfoPng(<a class="code" href="struct_lode_p_n_g___info_png.html">LodePNG_InfoPng</a>&amp; info); <span class="comment">//faster than copying with setInfoPng</span>
<a name="l00986"></a>00986     
<a name="l00987"></a>00987     <span class="comment">//getters and setters for the raw image info, this describes how the encoder should interpret the input pixel buffer</span>
<a name="l00988"></a>00988     <span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; getInfoRaw() <span class="keyword">const</span>;
<a name="l00989"></a>00989     <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; getInfoRaw();
<a name="l00990"></a>00990     <span class="keywordtype">void</span> setInfoRaw(<span class="keyword">const</span> <a class="code" href="struct_lode_p_n_g___info_raw.html">LodePNG_InfoRaw</a>&amp; info);
<a name="l00991"></a>00991   };
<a name="l00992"></a>00992   
<a name="l00993"></a>00993 <span class="preprocessor">#endif //LODEPNG_COMPILE_ENCODER</span>
<a name="l00994"></a>00994 <span class="preprocessor"></span>  
<a name="l00995"></a>00995 <span class="preprocessor">#ifdef LODEPNG_COMPILE_DISK</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00997"></a>00997 <span class="comment">  loadFile</span>
<a name="l00998"></a>00998 <span class="comment">  Load a file from disk into an std::vector. If the vector is empty, then either</span>
<a name="l00999"></a>00999 <span class="comment">  the file doesn&#39;t exist or is an empty file.</span>
<a name="l01000"></a>01000 <span class="comment">  */</span>
<a name="l01001"></a>01001   <span class="keywordtype">void</span> loadFile(std::vector&lt;unsigned char&gt;&amp; buffer, <span class="keyword">const</span> std::string&amp; filename);
<a name="l01002"></a>01002   
<a name="l01003"></a>01003   <span class="comment">/*</span>
<a name="l01004"></a>01004 <span class="comment">  saveFile</span>
<a name="l01005"></a>01005 <span class="comment">  Save the binary data in an std::vector to a file on disk. The file is overwritten</span>
<a name="l01006"></a>01006 <span class="comment">  without warning.</span>
<a name="l01007"></a>01007 <span class="comment">  */</span>
<a name="l01008"></a>01008   <span class="keywordtype">void</span> saveFile(<span class="keyword">const</span> std::vector&lt;unsigned char&gt;&amp; buffer, <span class="keyword">const</span> std::string&amp; filename);
<a name="l01009"></a>01009 <span class="preprocessor">#endif //LODEPNG_COMPILE_DISK</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>  
<a name="l01011"></a>01011 } <span class="comment">//namespace LodePNG</span>
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="preprocessor">#endif //LODEPNG_COMPILE_PNG</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>
<a name="l01015"></a>01015 <span class="preprocessor">#endif </span><span class="comment">/*end of __cplusplus wrapper*/</span>
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 <span class="comment">/*</span>
<a name="l01018"></a>01018 <span class="comment">TODO:</span>
<a name="l01019"></a>01019 <span class="comment">[ ] test if there are no memory leaks or security exploits - done a lot but needs to be checked often</span>
<a name="l01020"></a>01020 <span class="comment">[ ] LZ77 encoder more like the one described in zlib - to make sure it&#39;s patentfree</span>
<a name="l01021"></a>01021 <span class="comment">[ ] converting color to 16-bit per channel types</span>
<a name="l01022"></a>01022 <span class="comment">[ ] read all public PNG chunk types (but never let the color profile and gamma ones ever touch RGB values, that is very annoying for textures as well as images in a browser)</span>
<a name="l01023"></a>01023 <span class="comment">[ ] make sure encoder generates no chunks with size &gt; (2^31)-1</span>
<a name="l01024"></a>01024 <span class="comment">[ ] partial decoding (stream processing)</span>
<a name="l01025"></a>01025 <span class="comment">[ ] let the &quot;isFullyOpaque&quot; function check color keys and transparent palettes too</span>
<a name="l01026"></a>01026 <span class="comment">[ ] better name for the variables &quot;codes&quot;, &quot;codesD&quot;, &quot;codelengthcodes&quot;, &quot;clcl&quot; and &quot;lldl&quot;</span>
<a name="l01027"></a>01027 <span class="comment">[ ] check compatibility with vareous compilers  - done but needs to be redone for every newer version</span>
<a name="l01028"></a>01028 <span class="comment">[ ] don&#39;t stop decoding on errors like 69, 57, 58 (make warnings that the decoder stores in the error at the very end? and make some errors just let it stop with this one chunk but still do the next ones)</span>
<a name="l01029"></a>01029 <span class="comment">[ ] make option to choose if the raw image with non multiple of 8 bits per scanline should have padding bits or not, if people like storing raw images that way</span>
<a name="l01030"></a>01030 <span class="comment">*/</span>
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="preprocessor">#endif</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span>
<a name="l01034"></a>01034 <span class="comment">/*</span>
<a name="l01035"></a>01035 <span class="comment">LodePNG Documentation</span>
<a name="l01036"></a>01036 <span class="comment">---------------------</span>
<a name="l01037"></a>01037 <span class="comment"></span>
<a name="l01038"></a>01038 <span class="comment">This documentations contains background information and examples. For the function</span>
<a name="l01039"></a>01039 <span class="comment">and class documentation, see the comments in the declarations above.</span>
<a name="l01040"></a>01040 <span class="comment"></span>
<a name="l01041"></a>01041 <span class="comment">0. table of contents</span>
<a name="l01042"></a>01042 <span class="comment">--------------------</span>
<a name="l01043"></a>01043 <span class="comment"></span>
<a name="l01044"></a>01044 <span class="comment">  1. about</span>
<a name="l01045"></a>01045 <span class="comment">   1.1. supported features</span>
<a name="l01046"></a>01046 <span class="comment">   1.2. features not supported</span>
<a name="l01047"></a>01047 <span class="comment">  2. C and C++ version</span>
<a name="l01048"></a>01048 <span class="comment">  3. security</span>
<a name="l01049"></a>01049 <span class="comment">  4. decoding</span>
<a name="l01050"></a>01050 <span class="comment">  5. encoding</span>
<a name="l01051"></a>01051 <span class="comment">  6. color conversions</span>
<a name="l01052"></a>01052 <span class="comment">    6.1. PNG color types</span>
<a name="l01053"></a>01053 <span class="comment">    6.2. Default Behaviour of LodePNG</span>
<a name="l01054"></a>01054 <span class="comment">    6.3. Color Conversions</span>
<a name="l01055"></a>01055 <span class="comment">    6.4. More Notes</span>
<a name="l01056"></a>01056 <span class="comment">  7. error values</span>
<a name="l01057"></a>01057 <span class="comment">  8. chunks and PNG editing</span>
<a name="l01058"></a>01058 <span class="comment">  9. compiler support</span>
<a name="l01059"></a>01059 <span class="comment">  10. examples</span>
<a name="l01060"></a>01060 <span class="comment">   10.1. decoder C++ example</span>
<a name="l01061"></a>01061 <span class="comment">   10.2. encoder C++ example</span>
<a name="l01062"></a>01062 <span class="comment">   10.3. decoder C example</span>
<a name="l01063"></a>01063 <span class="comment">  11. changes</span>
<a name="l01064"></a>01064 <span class="comment">  12. contact information</span>
<a name="l01065"></a>01065 <span class="comment"></span>
<a name="l01066"></a>01066 <span class="comment"></span>
<a name="l01067"></a>01067 <span class="comment">1. about</span>
<a name="l01068"></a>01068 <span class="comment">--------</span>
<a name="l01069"></a>01069 <span class="comment"></span>
<a name="l01070"></a>01070 <span class="comment">PNG is a file format to store raster images losslessly with good compression,</span>
<a name="l01071"></a>01071 <span class="comment">supporting different color types. It can be implemented in a patent-free way.</span>
<a name="l01072"></a>01072 <span class="comment"></span>
<a name="l01073"></a>01073 <span class="comment">LodePNG is a PNG codec according to the Portable Network Graphics (PNG)</span>
<a name="l01074"></a>01074 <span class="comment">Specification (Second Edition) - W3C Recommendation 10 November 2003.</span>
<a name="l01075"></a>01075 <span class="comment"></span>
<a name="l01076"></a>01076 <span class="comment">The specifications used are:</span>
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01078"></a>01078 <span class="comment">*) Portable Network Graphics (PNG) Specification (Second Edition):</span>
<a name="l01079"></a>01079 <span class="comment">     http://www.w3.org/TR/2003/REC-PNG-20031110</span>
<a name="l01080"></a>01080 <span class="comment">*) RFC 1950 ZLIB Compressed Data Format version 3.3:</span>
<a name="l01081"></a>01081 <span class="comment">     http://www.gzip.org/zlib/rfc-zlib.html</span>
<a name="l01082"></a>01082 <span class="comment">*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:</span>
<a name="l01083"></a>01083 <span class="comment">     http://www.gzip.org/zlib/rfc-deflate.html</span>
<a name="l01084"></a>01084 <span class="comment"></span>
<a name="l01085"></a>01085 <span class="comment">The most recent version of LodePNG can currently be found at</span>
<a name="l01086"></a>01086 <span class="comment">http://members.gamedev.net/lode/projects/LodePNG/</span>
<a name="l01087"></a>01087 <span class="comment"></span>
<a name="l01088"></a>01088 <span class="comment">LodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds</span>
<a name="l01089"></a>01089 <span class="comment">extra functionality.</span>
<a name="l01090"></a>01090 <span class="comment"></span>
<a name="l01091"></a>01091 <span class="comment">LodePNG exists out of two files:</span>
<a name="l01092"></a>01092 <span class="comment">-lodepng.h: the header file for both C and C++</span>
<a name="l01093"></a>01093 <span class="comment">-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp depending on your usage</span>
<a name="l01094"></a>01094 <span class="comment"></span>
<a name="l01095"></a>01095 <span class="comment">If you want to start using LodePNG right away without reading this doc, get the</span>
<a name="l01096"></a>01096 <span class="comment">files lodepng_examples.c or lodepng_examples.cpp to see how to use it in code,</span>
<a name="l01097"></a>01097 <span class="comment">or check the (smaller) examples in chapter 13 here.</span>
<a name="l01098"></a>01098 <span class="comment"></span>
<a name="l01099"></a>01099 <span class="comment">LodePNG is simple but only supports the basic requirements. To achieve</span>
<a name="l01100"></a>01100 <span class="comment">simplicity, the following design choices were made: There are no dependencies</span>
<a name="l01101"></a>01101 <span class="comment">on any external library. To decode PNGs, there&#39;s a Decoder struct or class that</span>
<a name="l01102"></a>01102 <span class="comment">can convert any PNG file data into an RGBA image buffer with a single function</span>
<a name="l01103"></a>01103 <span class="comment">call. To encode PNGs, there&#39;s an Encoder struct or class that can convert image</span>
<a name="l01104"></a>01104 <span class="comment">data into PNG file data with a single function call. To read and write files,</span>
<a name="l01105"></a>01105 <span class="comment">there are simple functions to convert the files to/from buffers in memory.</span>
<a name="l01106"></a>01106 <span class="comment"></span>
<a name="l01107"></a>01107 <span class="comment">This all makes LodePNG suitable for loading textures in games, demoscene</span>
<a name="l01108"></a>01108 <span class="comment">productions, saving a screenshot, images in programs that require them for simple</span>
<a name="l01109"></a>01109 <span class="comment">usage, ... It&#39;s less suitable for full fledged image editors, loading PNGs</span>
<a name="l01110"></a>01110 <span class="comment">over network (it requires all the image data to be available before decoding can</span>
<a name="l01111"></a>01111 <span class="comment">begin), life-critical systems, ...</span>
<a name="l01112"></a>01112 <span class="comment">LodePNG has a standards conformant decoder and encoder, and supports the ability</span>
<a name="l01113"></a>01113 <span class="comment">to make a somewhat conformant editor.</span>
<a name="l01114"></a>01114 <span class="comment"></span>
<a name="l01115"></a>01115 <span class="comment">1.1. supported features</span>
<a name="l01116"></a>01116 <span class="comment">-----------------------</span>
<a name="l01117"></a>01117 <span class="comment"></span>
<a name="l01118"></a>01118 <span class="comment">The following features are supported by the decoder:</span>
<a name="l01119"></a>01119 <span class="comment"></span>
<a name="l01120"></a>01120 <span class="comment">*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image, or the same color type as the PNG</span>
<a name="l01121"></a>01121 <span class="comment">*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image</span>
<a name="l01122"></a>01122 <span class="comment">*) Adam7 interlace and deinterlace for any color type</span>
<a name="l01123"></a>01123 <span class="comment">*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk</span>
<a name="l01124"></a>01124 <span class="comment">*) support for alpha channels, including RGBA color model, translucent palettes and color keying</span>
<a name="l01125"></a>01125 <span class="comment">*) zlib decompression (inflate)</span>
<a name="l01126"></a>01126 <span class="comment">*) zlib compression (deflate)</span>
<a name="l01127"></a>01127 <span class="comment">*) CRC32 and ADLER32 checksums</span>
<a name="l01128"></a>01128 <span class="comment">*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.</span>
<a name="l01129"></a>01129 <span class="comment">*) the following chunks are supported (generated/interpreted) by both encoder and decoder:</span>
<a name="l01130"></a>01130 <span class="comment">    IHDR: header information</span>
<a name="l01131"></a>01131 <span class="comment">    PLTE: color palette</span>
<a name="l01132"></a>01132 <span class="comment">    IDAT: pixel data</span>
<a name="l01133"></a>01133 <span class="comment">    IEND: the final chunk</span>
<a name="l01134"></a>01134 <span class="comment">    tRNS: transparency for palettized images</span>
<a name="l01135"></a>01135 <span class="comment">    tEXt: textual information</span>
<a name="l01136"></a>01136 <span class="comment">    zTXt: compressed textual information</span>
<a name="l01137"></a>01137 <span class="comment">    iTXt: international textual information</span>
<a name="l01138"></a>01138 <span class="comment">    bKGD: suggested background color</span>
<a name="l01139"></a>01139 <span class="comment">    pHYs: physical dimensions</span>
<a name="l01140"></a>01140 <span class="comment">    tIME: modification time</span>
<a name="l01141"></a>01141 <span class="comment"></span>
<a name="l01142"></a>01142 <span class="comment">1.2. features not supported</span>
<a name="l01143"></a>01143 <span class="comment">---------------------------</span>
<a name="l01144"></a>01144 <span class="comment"></span>
<a name="l01145"></a>01145 <span class="comment">The following features are _not_ supported:</span>
<a name="l01146"></a>01146 <span class="comment"></span>
<a name="l01147"></a>01147 <span class="comment">*) some features needed to make a conformant PNG-Editor might be still missing.</span>
<a name="l01148"></a>01148 <span class="comment">*) partial loading/stream processing. All data must be available and is processed in one call.</span>
<a name="l01149"></a>01149 <span class="comment">*) The following public chunks are not supported but treated as unknown chunks by LodePNG</span>
<a name="l01150"></a>01150 <span class="comment">    cHRM, gAMA, iCCP, sRGB, sBIT, hIST, sPLT</span>
<a name="l01151"></a>01151 <span class="comment"></span>
<a name="l01152"></a>01152 <span class="comment"></span>
<a name="l01153"></a>01153 <span class="comment">2. C and C++ version</span>
<a name="l01154"></a>01154 <span class="comment">--------------------</span>
<a name="l01155"></a>01155 <span class="comment"></span>
<a name="l01156"></a>01156 <span class="comment">The C version uses buffers allocated with alloc that you need to free()</span>
<a name="l01157"></a>01157 <span class="comment">yourself. On top of that, you need to use init and cleanup functions for each</span>
<a name="l01158"></a>01158 <span class="comment">struct whenever using a struct from the C version to avoid exploits and memory leaks.</span>
<a name="l01159"></a>01159 <span class="comment"></span>
<a name="l01160"></a>01160 <span class="comment">The C++ version has constructors and destructors that take care of these things,</span>
<a name="l01161"></a>01161 <span class="comment">and uses std::vectors in the interface for storing data.</span>
<a name="l01162"></a>01162 <span class="comment"></span>
<a name="l01163"></a>01163 <span class="comment">Both the C and the C++ version are contained in this file! The C++ code depends on</span>
<a name="l01164"></a>01164 <span class="comment">the C code, the C code works on its own.</span>
<a name="l01165"></a>01165 <span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment">These files work without modification for both C and C++ compilers because all the</span>
<a name="l01167"></a>01167 <span class="comment">additional C++ code is in &quot;#ifdef __cplusplus&quot; blocks that make C-compilers ignore</span>
<a name="l01168"></a>01168 <span class="comment">it, and the C code is made to compile both with strict ISO C90 and C++.</span>
<a name="l01169"></a>01169 <span class="comment"></span>
<a name="l01170"></a>01170 <span class="comment">To use the C++ version, you need to rename the source file to lodepng.cpp (instead</span>
<a name="l01171"></a>01171 <span class="comment">of lodepng.c), and compile it with a C++ compiler.</span>
<a name="l01172"></a>01172 <span class="comment"></span>
<a name="l01173"></a>01173 <span class="comment">To use the C version, you need to rename the source file to lodepng.c (instead</span>
<a name="l01174"></a>01174 <span class="comment">of lodepng.cpp), and compile it with a C compiler.</span>
<a name="l01175"></a>01175 <span class="comment"></span>
<a name="l01176"></a>01176 <span class="comment"></span>
<a name="l01177"></a>01177 <span class="comment">3. Security</span>
<a name="l01178"></a>01178 <span class="comment">-----------</span>
<a name="l01179"></a>01179 <span class="comment"></span>
<a name="l01180"></a>01180 <span class="comment">As with most software, even if carefully designed, it&#39;s always possible that</span>
<a name="l01181"></a>01181 <span class="comment">LodePNG may contain possible exploits.</span>
<a name="l01182"></a>01182 <span class="comment"></span>
<a name="l01183"></a>01183 <span class="comment">If you discover a possible exploit, please let me know, and it will be fixed.</span>
<a name="l01184"></a>01184 <span class="comment"></span>
<a name="l01185"></a>01185 <span class="comment">When using LodePNG, care has to be taken with the C version of LodePNG, as well as the C-style</span>
<a name="l01186"></a>01186 <span class="comment">structs when working with C++. The following conventions are used for all C-style structs:</span>
<a name="l01187"></a>01187 <span class="comment"></span>
<a name="l01188"></a>01188 <span class="comment">-if a struct has a corresponding init function, always call the init function when making a new one, to avoid exploits</span>
<a name="l01189"></a>01189 <span class="comment">-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks</span>
<a name="l01190"></a>01190 <span class="comment">-if a struct has a corresponding copy function, use the copy function instead of &quot;=&quot;. The destination must also be inited already!</span>
<a name="l01191"></a>01191 <span class="comment"></span>
<a name="l01192"></a>01192 <span class="comment">4. Decoding</span>
<a name="l01193"></a>01193 <span class="comment">-----------</span>
<a name="l01194"></a>01194 <span class="comment"></span>
<a name="l01195"></a>01195 <span class="comment">Decoding converts a PNG compressed image to a raw pixel buffer.</span>
<a name="l01196"></a>01196 <span class="comment"></span>
<a name="l01197"></a>01197 <span class="comment">Most documentation on using the decoder is at its declarations in the header</span>
<a name="l01198"></a>01198 <span class="comment">above. For C, simple decoding can be done with functions such as LodePNG_decode32,</span>
<a name="l01199"></a>01199 <span class="comment">and more advanced decoding can be done with the struct LodePNG_Decoder and its</span>
<a name="l01200"></a>01200 <span class="comment">functions. For C++, simple decoding can be done with the LodePNG::decode functions</span>
<a name="l01201"></a>01201 <span class="comment">and advanced decoding with the LodePNG::Decoder class.</span>
<a name="l01202"></a>01202 <span class="comment"></span>
<a name="l01203"></a>01203 <span class="comment">The Decoder contains 3 components:</span>
<a name="l01204"></a>01204 <span class="comment">*) LodePNG_InfoPng: it stores information about the PNG (the input) in an LodePNG_InfoPng struct, don&#39;t modify this one yourself</span>
<a name="l01205"></a>01205 <span class="comment">*) Settings: you can specify a few other settings for the decoder to use</span>
<a name="l01206"></a>01206 <span class="comment">*) LodePNG_InfoRaw: here you can say what type of raw image (the output) you want to get</span>
<a name="l01207"></a>01207 <span class="comment"></span>
<a name="l01208"></a>01208 <span class="comment">Some of the parameters described below may be inside the sub-struct &quot;LodePNG_InfoColor color&quot;.</span>
<a name="l01209"></a>01209 <span class="comment">In the C and C++ version, when using Info structs outside of the decoder or encoder, you need to use their</span>
<a name="l01210"></a>01210 <span class="comment">init and cleanup functions, but normally you use the ones in the decoder that are already handled</span>
<a name="l01211"></a>01211 <span class="comment">in the init and cleanup functions of the decoder itself.</span>
<a name="l01212"></a>01212 <span class="comment"></span>
<a name="l01213"></a>01213 <span class="comment">=LodePNG_InfoPng=</span>
<a name="l01214"></a>01214 <span class="comment"></span>
<a name="l01215"></a>01215 <span class="comment">This contains information such as the original color type of the PNG image, text</span>
<a name="l01216"></a>01216 <span class="comment">comments, suggested background color, etc... More details about the LodePNG_InfoPng struct</span>
<a name="l01217"></a>01217 <span class="comment">are at its declaration documentation.</span>
<a name="l01218"></a>01218 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">Because the dimensions of the image are important, there are shortcuts to get them in the</span>
<a name="l01220"></a>01220 <span class="comment">C++ version: use decoder.getWidth() and decoder.getHeight().</span>
<a name="l01221"></a>01221 <span class="comment">In the C version, use decoder.infoPng.width and decoder.infoPng.height.</span>
<a name="l01222"></a>01222 <span class="comment"></span>
<a name="l01223"></a>01223 <span class="comment">=LodePNG_InfoRaw=</span>
<a name="l01224"></a>01224 <span class="comment"></span>
<a name="l01225"></a>01225 <span class="comment">In the LodePNG_InfoRaw struct of the Decoder, you can specify which color type you want</span>
<a name="l01226"></a>01226 <span class="comment">the resulting raw image to be. If this is different from the colorType of the</span>
<a name="l01227"></a>01227 <span class="comment">PNG, then the decoder will automatically convert the result to your LodePNG_InfoRaw</span>
<a name="l01228"></a>01228 <span class="comment">settings. Not all combinations of color conversions are supported though, see</span>
<a name="l01229"></a>01229 <span class="comment">a different section for information about the color modes and supported conversions.</span>
<a name="l01230"></a>01230 <span class="comment"></span>
<a name="l01231"></a>01231 <span class="comment">Palette of LodePNG_InfoRaw isn&#39;t used by the Decoder, when converting from palette color</span>
<a name="l01232"></a>01232 <span class="comment">to palette color, the values of the pixels are left untouched so that the colors</span>
<a name="l01233"></a>01233 <span class="comment">will change if the palette is different. Color key of LodePNG_InfoRaw is not used by the</span>
<a name="l01234"></a>01234 <span class="comment">Decoder. If setting color_convert is false then LodePNG_InfoRaw is completely ignored,</span>
<a name="l01235"></a>01235 <span class="comment">but it will be modified to match the color type of the PNG so will be overwritten.</span>
<a name="l01236"></a>01236 <span class="comment"></span>
<a name="l01237"></a>01237 <span class="comment">By default, 32-bit color is used for the result.</span>
<a name="l01238"></a>01238 <span class="comment"></span>
<a name="l01239"></a>01239 <span class="comment">=Settings=</span>
<a name="l01240"></a>01240 <span class="comment"></span>
<a name="l01241"></a>01241 <span class="comment">The Settings can be used to ignore the errors created by invalid CRC and Adler32</span>
<a name="l01242"></a>01242 <span class="comment">chunks, and to disable the decoding of tEXt chunks.</span>
<a name="l01243"></a>01243 <span class="comment"></span>
<a name="l01244"></a>01244 <span class="comment">There&#39;s also a setting color_convert, true by default. If false, no conversion</span>
<a name="l01245"></a>01245 <span class="comment">is done, the resulting data will be as it was in the PNG (after decompression)</span>
<a name="l01246"></a>01246 <span class="comment">and you&#39;ll have to puzzle the colors of the pixels together yourself using the</span>
<a name="l01247"></a>01247 <span class="comment">color type information in the LodePNG_InfoPng.</span>
<a name="l01248"></a>01248 <span class="comment"></span>
<a name="l01249"></a>01249 <span class="comment"></span>
<a name="l01250"></a>01250 <span class="comment">5. Encoding</span>
<a name="l01251"></a>01251 <span class="comment">-----------</span>
<a name="l01252"></a>01252 <span class="comment"></span>
<a name="l01253"></a>01253 <span class="comment">Encoding converts a raw pixel buffer to a PNG compressed image.</span>
<a name="l01254"></a>01254 <span class="comment"></span>
<a name="l01255"></a>01255 <span class="comment">Most documentation on using the encoder is at its declarations in the header</span>
<a name="l01256"></a>01256 <span class="comment">above. For C, simple encoding can be done with functions such as LodePNG_encode32,</span>
<a name="l01257"></a>01257 <span class="comment">and more advanced decoding can be done with the struct LodePNG_Encoder and its</span>
<a name="l01258"></a>01258 <span class="comment">functions. For C++, simple encoding can be done with the LodePNG::encode functions</span>
<a name="l01259"></a>01259 <span class="comment">and advanced decoding with the LodePNG::Encoder class.</span>
<a name="l01260"></a>01260 <span class="comment"></span>
<a name="l01261"></a>01261 <span class="comment">Like the decoder, the encoder can also give errors. However it gives less errors</span>
<a name="l01262"></a>01262 <span class="comment">since the encoder input is trusted, the decoder input (a PNG image that could</span>
<a name="l01263"></a>01263 <span class="comment">be forged by anyone) is not trusted.</span>
<a name="l01264"></a>01264 <span class="comment"></span>
<a name="l01265"></a>01265 <span class="comment">Like the Decoder, the Encoder has 3 components:</span>
<a name="l01266"></a>01266 <span class="comment">*) LodePNG_InfoRaw: here you say what color type of the raw image (the input) has</span>
<a name="l01267"></a>01267 <span class="comment">*) Settings: you can specify a few settings for the encoder to use</span>
<a name="l01268"></a>01268 <span class="comment">*) LodePNG_InfoPng: the same LodePNG_InfoPng struct as created by the Decoder. For the encoder,</span>
<a name="l01269"></a>01269 <span class="comment">with this you specify how you want the PNG (the output) to be.</span>
<a name="l01270"></a>01270 <span class="comment"></span>
<a name="l01271"></a>01271 <span class="comment">Some of the parameters described below may be inside the sub-struct &quot;LodePNG_InfoColor color&quot;.</span>
<a name="l01272"></a>01272 <span class="comment">In the C and C++ version, when using Info structs outside of the decoder or encoder, you need to use their</span>
<a name="l01273"></a>01273 <span class="comment">init and cleanup functions, but normally you use the ones in the encoder that are already handled</span>
<a name="l01274"></a>01274 <span class="comment">in the init and cleanup functions of the decoder itself.</span>
<a name="l01275"></a>01275 <span class="comment"></span>
<a name="l01276"></a>01276 <span class="comment">=LodePNG_InfoPng=</span>
<a name="l01277"></a>01277 <span class="comment"></span>
<a name="l01278"></a>01278 <span class="comment">The Decoder class stores information about the PNG image in an LodePNG_InfoPng object. With</span>
<a name="l01279"></a>01279 <span class="comment">the Encoder you can do the opposite: you give it an LodePNG_InfoPng object, and it&#39;ll try</span>
<a name="l01280"></a>01280 <span class="comment">to match the LodePNG_InfoPng you give as close as possible in the PNG it encodes. For</span>
<a name="l01281"></a>01281 <span class="comment">example in the LodePNG_InfoPng you can specify the color type you want to use, possible</span>
<a name="l01282"></a>01282 <span class="comment">tEXt chunks you want the PNG to contain, etc... For an explanation of all the</span>
<a name="l01283"></a>01283 <span class="comment">values in LodePNG_InfoPng see a further section. Not all PNG color types are supported</span>
<a name="l01284"></a>01284 <span class="comment">by the Encoder.</span>
<a name="l01285"></a>01285 <span class="comment"></span>
<a name="l01286"></a>01286 <span class="comment">The encoder will not always exactly match the LodePNG_InfoPng struct you give,</span>
<a name="l01287"></a>01287 <span class="comment">it tries as close as possible. Some things are ignored by the encoder. The width</span>
<a name="l01288"></a>01288 <span class="comment">and height of LodePNG_InfoPng are ignored as well, because instead the width and</span>
<a name="l01289"></a>01289 <span class="comment">height of the raw image you give in the input are used. In fact the encoder</span>
<a name="l01290"></a>01290 <span class="comment">currently uses only the following settings from it:</span>
<a name="l01291"></a>01291 <span class="comment">-colorType and bitDepth: the ones it supports</span>
<a name="l01292"></a>01292 <span class="comment">-text chunks, that you can add to the LodePNG_InfoPng with &quot;addText&quot;</span>
<a name="l01293"></a>01293 <span class="comment">-the color key, if applicable for the given color type</span>
<a name="l01294"></a>01294 <span class="comment">-the palette, if you encode to a PNG with colorType 3</span>
<a name="l01295"></a>01295 <span class="comment">-the background color: it&#39;ll add a bKGD chunk to the PNG if one is given</span>
<a name="l01296"></a>01296 <span class="comment">-the interlaceMethod: None (0) or Adam7 (1)</span>
<a name="l01297"></a>01297 <span class="comment"></span>
<a name="l01298"></a>01298 <span class="comment">When encoding to a PNG with colorType 3, the encoder will generate a PLTE chunk.</span>
<a name="l01299"></a>01299 <span class="comment">If the palette contains any colors for which the alpha channel is not 255 (so</span>
<a name="l01300"></a>01300 <span class="comment">there are translucent colors in the palette), it&#39;ll add a tRNS chunk.</span>
<a name="l01301"></a>01301 <span class="comment"></span>
<a name="l01302"></a>01302 <span class="comment">=LodePNG_InfoRaw=</span>
<a name="l01303"></a>01303 <span class="comment"></span>
<a name="l01304"></a>01304 <span class="comment">You specify the color type of the raw image that you give to the input here,</span>
<a name="l01305"></a>01305 <span class="comment">including a possible transparent color key and palette you happen to be using in</span>
<a name="l01306"></a>01306 <span class="comment">your raw image data.</span>
<a name="l01307"></a>01307 <span class="comment"></span>
<a name="l01308"></a>01308 <span class="comment">By default, 32-bit color is assumed, meaning your input has to be in RGBA</span>
<a name="l01309"></a>01309 <span class="comment">format with 4 bytes (unsigned chars) per pixel.</span>
<a name="l01310"></a>01310 <span class="comment"></span>
<a name="l01311"></a>01311 <span class="comment">=Settings=</span>
<a name="l01312"></a>01312 <span class="comment"></span>
<a name="l01313"></a>01313 <span class="comment">The following settings are supported (some are in sub-structs):</span>
<a name="l01314"></a>01314 <span class="comment">*) autoLeaveOutAlphaChannel: when this option is enabled, when you specify a PNG</span>
<a name="l01315"></a>01315 <span class="comment">color type with alpha channel (not to be confused with the color type of the raw</span>
<a name="l01316"></a>01316 <span class="comment">image you specify!!), but the encoder detects that all pixels of the given image</span>
<a name="l01317"></a>01317 <span class="comment">are opaque, then it&#39;ll automatically use the corresponding type without alpha</span>
<a name="l01318"></a>01318 <span class="comment">channel, resulting in a smaller PNG image.</span>
<a name="l01319"></a>01319 <span class="comment">*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree, 2 = dynamic huffman tree (best compression)</span>
<a name="l01320"></a>01320 <span class="comment">*) useLZ77: whether or not to use LZ77 for compressed block types</span>
<a name="l01321"></a>01321 <span class="comment">*) windowSize: the window size used by the LZ77 encoder (1 - 32768)</span>
<a name="l01322"></a>01322 <span class="comment">*) force_palette: if colorType is 2 or 6, you can make the encoder write a PLTE</span>
<a name="l01323"></a>01323 <span class="comment">   chunk if force_palette is true. This can used as suggested palette to convert</span>
<a name="l01324"></a>01324 <span class="comment">   to by viewers that don&#39;t support more than 256 colors (if those still exist)</span>
<a name="l01325"></a>01325 <span class="comment">*) add_id: add text chunk &quot;Encoder: LodePNG &lt;version&gt;&quot; to the image.</span>
<a name="l01326"></a>01326 <span class="comment">*) text_compression: default 0. If 1, it&#39;ll store texts as zTXt instead of tEXt chunks.</span>
<a name="l01327"></a>01327 <span class="comment">  zTXt chunks use zlib compression on the text. This gives a smaller result on</span>
<a name="l01328"></a>01328 <span class="comment">  large texts but a larger result on small texts (such as a single program name).</span>
<a name="l01329"></a>01329 <span class="comment">  It&#39;s all tEXt or all zTXt though, there&#39;s no separate setting per text yet.</span>
<a name="l01330"></a>01330 <span class="comment"></span>
<a name="l01331"></a>01331 <span class="comment"></span>
<a name="l01332"></a>01332 <span class="comment">6. color conversions</span>
<a name="l01333"></a>01333 <span class="comment">--------------------</span>
<a name="l01334"></a>01334 <span class="comment"></span>
<a name="l01335"></a>01335 <span class="comment">In LodePNG, the color mode (bits, channels and palette) used in the PNG image,</span>
<a name="l01336"></a>01336 <span class="comment">and the color mode used in the raw data, are separate and independently</span>
<a name="l01337"></a>01337 <span class="comment">configurable. Therefore, LodePNG needs to do conversions from one color mode to</span>
<a name="l01338"></a>01338 <span class="comment">another. Not all possible conversions are supported (e.g. converting to a color</span>
<a name="l01339"></a>01339 <span class="comment">model with palette isn&#39;t supported). This section will explain which conversions</span>
<a name="l01340"></a>01340 <span class="comment">are supported and how to configure this. This explains for example when LodePNG</span>
<a name="l01341"></a>01341 <span class="comment">uses the settings in LodePNG_InfoPng, LodePNG_InfoRaw and Settings.</span>
<a name="l01342"></a>01342 <span class="comment"></span>
<a name="l01343"></a>01343 <span class="comment">6.1. PNG color types</span>
<a name="l01344"></a>01344 <span class="comment">--------------------</span>
<a name="l01345"></a>01345 <span class="comment"></span>
<a name="l01346"></a>01346 <span class="comment">A PNG image can have many color types, ranging from 1-bit color to 64-bit color,</span>
<a name="l01347"></a>01347 <span class="comment">as well as palettized color modes. After the zlib decompression and unfiltering</span>
<a name="l01348"></a>01348 <span class="comment">in the PNG image is done, the raw pixel data will have that color type and thus</span>
<a name="l01349"></a>01349 <span class="comment">a certain amount of bits per pixel. If you want the output raw image after</span>
<a name="l01350"></a>01350 <span class="comment">decoding to have another color type, a conversion is done by LodePNG.</span>
<a name="l01351"></a>01351 <span class="comment"></span>
<a name="l01352"></a>01352 <span class="comment">The PNG specification mentions the following color types:</span>
<a name="l01353"></a>01353 <span class="comment"></span>
<a name="l01354"></a>01354 <span class="comment">0: greyscale, bit depths 1, 2, 4, 8, 16</span>
<a name="l01355"></a>01355 <span class="comment">2: RGB, bit depths 8 and 16</span>
<a name="l01356"></a>01356 <span class="comment">3: palette, bit depths 1, 2, 4 and 8</span>
<a name="l01357"></a>01357 <span class="comment">4: greyscale with alpha, bit depths 8 and 16</span>
<a name="l01358"></a>01358 <span class="comment">6: RGBA, bit depths 8 and 16</span>
<a name="l01359"></a>01359 <span class="comment"></span>
<a name="l01360"></a>01360 <span class="comment">Bit depth is the amount of bits per color channel.</span>
<a name="l01361"></a>01361 <span class="comment"></span>
<a name="l01362"></a>01362 <span class="comment">6.2. Default Behaviour of LodePNG</span>
<a name="l01363"></a>01363 <span class="comment">---------------------------------</span>
<a name="l01364"></a>01364 <span class="comment"></span>
<a name="l01365"></a>01365 <span class="comment">By default, the Decoder will convert the data from the PNG to 32-bit RGBA color,</span>
<a name="l01366"></a>01366 <span class="comment">no matter what color type the PNG has, so that the result can be used directly</span>
<a name="l01367"></a>01367 <span class="comment">as a texture in OpenGL etc... without worries about what color type the original</span>
<a name="l01368"></a>01368 <span class="comment">image has.</span>
<a name="l01369"></a>01369 <span class="comment"></span>
<a name="l01370"></a>01370 <span class="comment">The Encoder assumes by default that the raw input you give it is a 32-bit RGBA</span>
<a name="l01371"></a>01371 <span class="comment">buffer and will store the PNG as either 32 bit or 24 bit depending on whether</span>
<a name="l01372"></a>01372 <span class="comment">or not any translucent pixels were detected in it.</span>
<a name="l01373"></a>01373 <span class="comment"></span>
<a name="l01374"></a>01374 <span class="comment">To get the default behaviour, don&#39;t change the values of LodePNG_InfoRaw and LodePNG_InfoPng of</span>
<a name="l01375"></a>01375 <span class="comment">the encoder, and don&#39;t change the values of LodePNG_InfoRaw of the decoder.</span>
<a name="l01376"></a>01376 <span class="comment"></span>
<a name="l01377"></a>01377 <span class="comment">6.3. Color Conversions</span>
<a name="l01378"></a>01378 <span class="comment">----------------------</span>
<a name="l01379"></a>01379 <span class="comment"></span>
<a name="l01380"></a>01380 <span class="comment">As explained in the sections about the Encoder and Decoder, you can specify</span>
<a name="l01381"></a>01381 <span class="comment">color types and bit depths in LodePNG_InfoPng and LodePNG_InfoRaw, to change the default behaviour</span>
<a name="l01382"></a>01382 <span class="comment">explained above. (for the Decoder you can only specify the LodePNG_InfoRaw, because the</span>
<a name="l01383"></a>01383 <span class="comment">LodePNG_InfoPng contains what the PNG file has).</span>
<a name="l01384"></a>01384 <span class="comment"></span>
<a name="l01385"></a>01385 <span class="comment">To avoid some confusion:</span>
<a name="l01386"></a>01386 <span class="comment">-the Decoder converts from PNG to raw image</span>
<a name="l01387"></a>01387 <span class="comment">-the Encoder converts from raw image to PNG</span>
<a name="l01388"></a>01388 <span class="comment">-the color type and bit depth in LodePNG_InfoRaw, are those of the raw image</span>
<a name="l01389"></a>01389 <span class="comment">-the color type and bit depth in LodePNG_InfoPng, are those of the PNG</span>
<a name="l01390"></a>01390 <span class="comment">-if the color type of the LodePNG_InfoRaw and PNG image aren&#39;t the same, a conversion</span>
<a name="l01391"></a>01391 <span class="comment">between the color types is done if the color types are supported. If it is not</span>
<a name="l01392"></a>01392 <span class="comment">supported, an error is returned.</span>
<a name="l01393"></a>01393 <span class="comment"></span>
<a name="l01394"></a>01394 <span class="comment">Supported color conversions:</span>
<a name="l01395"></a>01395 <span class="comment">-It&#39;s possible to load PNGs from any colortype and to save PNGs of any colorType.</span>
<a name="l01396"></a>01396 <span class="comment">-Both encoder and decoder use the same converter. So both encoder and decoder</span>
<a name="l01397"></a>01397 <span class="comment">suport the same color types at the input and the output. So the decoder supports</span>
<a name="l01398"></a>01398 <span class="comment">any type of PNG image and can convert it to certain types of raw image, while the</span>
<a name="l01399"></a>01399 <span class="comment">encoder supports any type of raw data but only certain color types for the output PNG.</span>
<a name="l01400"></a>01400 <span class="comment">-The converter can convert from _any_ input color type, to 24-bit RGB or 32-bit RGBA</span>
<a name="l01401"></a>01401 <span class="comment">-The converter can convert from greyscale input color type, to 8-bit greyscale or greyscale with alpha</span>
<a name="l01402"></a>01402 <span class="comment">-If both color types are the same, conversion from anything to anything is possible</span>
<a name="l01403"></a>01403 <span class="comment">-Color types that are invalid according to the PNG specification are not allowed</span>
<a name="l01404"></a>01404 <span class="comment">-When converting from a type with alpha channel to one without, the alpha channel information is discarded</span>
<a name="l01405"></a>01405 <span class="comment">-When converting from a type without alpha channel to one with, the result will be opaque except pixels that have the same color as the color key of the input if one was given</span>
<a name="l01406"></a>01406 <span class="comment">-When converting from 16-bit bitDepth to 8-bit bitDepth, the 16-bit precision information is lost, only the most significant byte is kept</span>
<a name="l01407"></a>01407 <span class="comment">-Converting from color to greyscale or to palette is not supported on purpose: there are multiple possible algorithms to do this color reduction, LodePNG does not want to pick one and leaves this choice to the user instead, because it&#39;s beyond the scope of PNG encoding.</span>
<a name="l01408"></a>01408 <span class="comment">-Converting from/to a palette type, only keeps the indices, it ignores the colors defined in the palette</span>
<a name="l01409"></a>01409 <span class="comment"></span>
<a name="l01410"></a>01410 <span class="comment">No conversion needed...:</span>
<a name="l01411"></a>01411 <span class="comment">-If the color type of the PNG image and raw image are the same, then no</span>
<a name="l01412"></a>01412 <span class="comment">conversion is done, and all color types are supported.</span>
<a name="l01413"></a>01413 <span class="comment">-In the encoder, you can make it save a PNG with any color by giving the</span>
<a name="l01414"></a>01414 <span class="comment">LodePNG_InfoRaw and LodePNG_InfoPng the same color type.</span>
<a name="l01415"></a>01415 <span class="comment">-In the decoder, you can make it store the pixel data in the same color type</span>
<a name="l01416"></a>01416 <span class="comment">as the PNG has, by setting the color_convert setting to false. Settings in</span>
<a name="l01417"></a>01417 <span class="comment">infoRaw are then ignored.</span>
<a name="l01418"></a>01418 <span class="comment"></span>
<a name="l01419"></a>01419 <span class="comment">The function LodePNG_convert does this, which is available in the interface but</span>
<a name="l01420"></a>01420 <span class="comment">normally isn&#39;t needed since the encoder and decoder already call it.</span>
<a name="l01421"></a>01421 <span class="comment"></span>
<a name="l01422"></a>01422 <span class="comment">6.4. More Notes</span>
<a name="l01423"></a>01423 <span class="comment">---------------</span>
<a name="l01424"></a>01424 <span class="comment"></span>
<a name="l01425"></a>01425 <span class="comment">In the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines</span>
<a name="l01426"></a>01426 <span class="comment">have a bit amount that isn&#39;t a multiple of 8, then padding bits are used so that each</span>
<a name="l01427"></a>01427 <span class="comment">scanline starts at a fresh byte.</span>
<a name="l01428"></a>01428 <span class="comment">However: The raw input image you give to the encoder, and the raw output image you get from the decoder</span>
<a name="l01429"></a>01429 <span class="comment">will NOT have these padding bits in that case, e.g. in the case of a 1-bit image with a width</span>
<a name="l01430"></a>01430 <span class="comment">of 7 pixels, the first pixel of the second scanline will the the 8th bit of the first byte,</span>
<a name="l01431"></a>01431 <span class="comment">not the first bit of a new byte.</span>
<a name="l01432"></a>01432 <span class="comment"></span>
<a name="l01433"></a>01433 <span class="comment">7. error values</span>
<a name="l01434"></a>01434 <span class="comment">---------------</span>
<a name="l01435"></a>01435 <span class="comment"></span>
<a name="l01436"></a>01436 <span class="comment">All functions in LodePNG that return an error code, return 0 if everything went </span>
<a name="l01437"></a>01437 <span class="comment">OK, or one of the code defined by LodePNG if there was an error.</span>
<a name="l01438"></a>01438 <span class="comment"></span>
<a name="l01439"></a>01439 <span class="comment">The meaning of the LodePNG error values can be retrieved with the function</span>
<a name="l01440"></a>01440 <span class="comment">LodePNG_error_text: given the numerical error code, it returns a description</span>
<a name="l01441"></a>01441 <span class="comment">of the error in English as a string.</span>
<a name="l01442"></a>01442 <span class="comment"></span>
<a name="l01443"></a>01443 <span class="comment">Check the implementation of LodePNG_error_text to see the meaning of each error code.</span>
<a name="l01444"></a>01444 <span class="comment"></span>
<a name="l01445"></a>01445 <span class="comment"></span>
<a name="l01446"></a>01446 <span class="comment">8. chunks and PNG editing</span>
<a name="l01447"></a>01447 <span class="comment">-------------------------</span>
<a name="l01448"></a>01448 <span class="comment"></span>
<a name="l01449"></a>01449 <span class="comment">If you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG</span>
<a name="l01450"></a>01450 <span class="comment">editor that should follow the rules about handling of unknown chunks, or if you</span>
<a name="l01451"></a>01451 <span class="comment">program is able to read other types of chunks than the ones handled by LodePNG,</span>
<a name="l01452"></a>01452 <span class="comment">then that&#39;s possible with the chunk functions of LodePNG.</span>
<a name="l01453"></a>01453 <span class="comment"></span>
<a name="l01454"></a>01454 <span class="comment">A PNG chunk has the following layout:</span>
<a name="l01455"></a>01455 <span class="comment"></span>
<a name="l01456"></a>01456 <span class="comment">4 bytes length</span>
<a name="l01457"></a>01457 <span class="comment">4 bytes type name</span>
<a name="l01458"></a>01458 <span class="comment">length bytes data</span>
<a name="l01459"></a>01459 <span class="comment">4 bytes CRC</span>
<a name="l01460"></a>01460 <span class="comment"></span>
<a name="l01461"></a>01461 <span class="comment"></span>
<a name="l01462"></a>01462 <span class="comment">8.1. iterating through chunks</span>
<a name="l01463"></a>01463 <span class="comment">-----------------------------</span>
<a name="l01464"></a>01464 <span class="comment"></span>
<a name="l01465"></a>01465 <span class="comment">If you have a buffer containing the PNG image data, then the first chunk (the</span>
<a name="l01466"></a>01466 <span class="comment">IHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the</span>
<a name="l01467"></a>01467 <span class="comment">signature of the PNG and are not part of a chunk. But if you start at byte 8</span>
<a name="l01468"></a>01468 <span class="comment">then you have a chunk, and can check the following things of it.</span>
<a name="l01469"></a>01469 <span class="comment"></span>
<a name="l01470"></a>01470 <span class="comment">NOTE: none of these functions check for memory buffer boundaries. To avoid</span>
<a name="l01471"></a>01471 <span class="comment">exploits, always make sure the buffer contains all the data of the chunks.</span>
<a name="l01472"></a>01472 <span class="comment">When using LodePNG_chunk_next, make sure the returned value is within the</span>
<a name="l01473"></a>01473 <span class="comment">allocated memory.</span>
<a name="l01474"></a>01474 <span class="comment"></span>
<a name="l01475"></a>01475 <span class="comment">unsigned LodePNG_chunk_length(const unsigned char* chunk):</span>
<a name="l01476"></a>01476 <span class="comment"></span>
<a name="l01477"></a>01477 <span class="comment">Get the length of the chunk&#39;s data. The total chunk length is this length + 12.</span>
<a name="l01478"></a>01478 <span class="comment"></span>
<a name="l01479"></a>01479 <span class="comment">void LodePNG_chunk_type(char type[5], const unsigned char* chunk):</span>
<a name="l01480"></a>01480 <span class="comment">unsigned char LodePNG_chunk_type_equals(const unsigned char* chunk, const char* type):</span>
<a name="l01481"></a>01481 <span class="comment"></span>
<a name="l01482"></a>01482 <span class="comment">Get the type of the chunk or compare if it&#39;s a certain type</span>
<a name="l01483"></a>01483 <span class="comment"></span>
<a name="l01484"></a>01484 <span class="comment">unsigned char LodePNG_chunk_critical(const unsigned char* chunk):</span>
<a name="l01485"></a>01485 <span class="comment">unsigned char LodePNG_chunk_private(const unsigned char* chunk):</span>
<a name="l01486"></a>01486 <span class="comment">unsigned char LodePNG_chunk_safetocopy(const unsigned char* chunk):</span>
<a name="l01487"></a>01487 <span class="comment"></span>
<a name="l01488"></a>01488 <span class="comment">Check if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).</span>
<a name="l01489"></a>01489 <span class="comment">Check if the chunk is private (public chunks are part of the standard, private ones not).</span>
<a name="l01490"></a>01490 <span class="comment">Check if the chunk is safe to copy. If it&#39;s not, then, when modifying data in a critical</span>
<a name="l01491"></a>01491 <span class="comment">chunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your</span>
<a name="l01492"></a>01492 <span class="comment">program doesn&#39;t handle that type of unknown chunk.</span>
<a name="l01493"></a>01493 <span class="comment"></span>
<a name="l01494"></a>01494 <span class="comment">unsigned char* LodePNG_chunk_data(unsigned char* chunk):</span>
<a name="l01495"></a>01495 <span class="comment">const unsigned char* LodePNG_chunk_data_const(const unsigned char* chunk):</span>
<a name="l01496"></a>01496 <span class="comment"></span>
<a name="l01497"></a>01497 <span class="comment">Get a pointer to the start of the data of the chunk.</span>
<a name="l01498"></a>01498 <span class="comment"></span>
<a name="l01499"></a>01499 <span class="comment">unsigned LodePNG_chunk_check_crc(const unsigned char* chunk):</span>
<a name="l01500"></a>01500 <span class="comment">void LodePNG_chunk_generate_crc(unsigned char* chunk):</span>
<a name="l01501"></a>01501 <span class="comment"></span>
<a name="l01502"></a>01502 <span class="comment">Check if the crc is correct or generate a correct one.</span>
<a name="l01503"></a>01503 <span class="comment"></span>
<a name="l01504"></a>01504 <span class="comment">unsigned char* LodePNG_chunk_next(unsigned char* chunk):</span>
<a name="l01505"></a>01505 <span class="comment">const unsigned char* LodePNG_chunk_next_const(const unsigned char* chunk):</span>
<a name="l01506"></a>01506 <span class="comment"></span>
<a name="l01507"></a>01507 <span class="comment">Iterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these</span>
<a name="l01508"></a>01508 <span class="comment">functions do no boundary checking of the allocated data whatsoever, so make sure there is enough</span>
<a name="l01509"></a>01509 <span class="comment">data available in the buffer to be able to go to the next chunk.</span>
<a name="l01510"></a>01510 <span class="comment"></span>
<a name="l01511"></a>01511 <span class="comment">unsigned LodePNG_append_chunk(unsigned char** out, size_t* outlength, const unsigned char* chunk):</span>
<a name="l01512"></a>01512 <span class="comment">unsigned LodePNG_create_chunk(unsigned char** out, size_t* outlength, unsigned length, const char* type, const unsigned char* data):</span>
<a name="l01513"></a>01513 <span class="comment"></span>
<a name="l01514"></a>01514 <span class="comment">These functions are used to create new chunks that are appended to the data in *out that has</span>
<a name="l01515"></a>01515 <span class="comment">length *outlength. The append function appends an existing chunk to the new data. The create</span>
<a name="l01516"></a>01516 <span class="comment">function creates a new chunk with the given parameters and appends it. Type is the 4-letter</span>
<a name="l01517"></a>01517 <span class="comment">name of the chunk.</span>
<a name="l01518"></a>01518 <span class="comment"></span>
<a name="l01519"></a>01519 <span class="comment"></span>
<a name="l01520"></a>01520 <span class="comment">8.2. chunks in infoPng</span>
<a name="l01521"></a>01521 <span class="comment">----------------------</span>
<a name="l01522"></a>01522 <span class="comment"></span>
<a name="l01523"></a>01523 <span class="comment">The LodePNG_InfoPng struct contains a struct LodePNG_UnknownChunks in it. This</span>
<a name="l01524"></a>01524 <span class="comment">struct has 3 buffers (each with size) to contain 3 types of unknown chunks:</span>
<a name="l01525"></a>01525 <span class="comment">the ones that come before the PLTE chunk, the ones that come between the PLTE</span>
<a name="l01526"></a>01526 <span class="comment">and the IDAT chunks, and the ones that come after the IDAT chunks.</span>
<a name="l01527"></a>01527 <span class="comment">It&#39;s necessary to make the distionction between these 3 cases because the PNG</span>
<a name="l01528"></a>01528 <span class="comment">standard forces to keep the ordering of unknown chunks compared to the critical</span>
<a name="l01529"></a>01529 <span class="comment">chunks, but does not force any other ordering rules.</span>
<a name="l01530"></a>01530 <span class="comment"></span>
<a name="l01531"></a>01531 <span class="comment">infoPng.unknown_chunks.data[0] is the chunks before PLTE</span>
<a name="l01532"></a>01532 <span class="comment">infoPng.unknown_chunks.data[1] is the chunks after PLTE, before IDAT</span>
<a name="l01533"></a>01533 <span class="comment">infoPng.unknown_chunks.data[2] is the chunks after IDAT</span>
<a name="l01534"></a>01534 <span class="comment"></span>
<a name="l01535"></a>01535 <span class="comment">The chunks in these 3 buffers can be iterated through and read by using the same</span>
<a name="l01536"></a>01536 <span class="comment">way described in the previous subchapter.</span>
<a name="l01537"></a>01537 <span class="comment"></span>
<a name="l01538"></a>01538 <span class="comment">When using the decoder to decode a PNG, you can make it store all unknown chunks</span>
<a name="l01539"></a>01539 <span class="comment">if you set the option settings.rememberUnknownChunks to 1. By default, this option</span>
<a name="l01540"></a>01540 <span class="comment">is off and is 0.</span>
<a name="l01541"></a>01541 <span class="comment"></span>
<a name="l01542"></a>01542 <span class="comment">The encoder will always encode unknown chunks that are stored in the infoPng. If</span>
<a name="l01543"></a>01543 <span class="comment">you need it to add a particular chunk that isn&#39;t known by LodePNG, you can use</span>
<a name="l01544"></a>01544 <span class="comment">LodePNG_append_chunk or LodePNG_create_chunk to the chunk data in</span>
<a name="l01545"></a>01545 <span class="comment">infoPng.unknown_chunks.data[x].</span>
<a name="l01546"></a>01546 <span class="comment"></span>
<a name="l01547"></a>01547 <span class="comment">Chunks that are known by LodePNG should not be added in that way. E.g. to make</span>
<a name="l01548"></a>01548 <span class="comment">LodePNG add a bKGD chunk, set background_defined to true and add the correct</span>
<a name="l01549"></a>01549 <span class="comment">parameters there and LodePNG will generate the chunk.</span>
<a name="l01550"></a>01550 <span class="comment"></span>
<a name="l01551"></a>01551 <span class="comment"></span>
<a name="l01552"></a>01552 <span class="comment">9. compiler support</span>
<a name="l01553"></a>01553 <span class="comment">-------------------</span>
<a name="l01554"></a>01554 <span class="comment"></span>
<a name="l01555"></a>01555 <span class="comment">No libraries other than the current standard C library are needed to compile</span>
<a name="l01556"></a>01556 <span class="comment">LodePNG. For the C++ version, only the standard C++ library is needed on top.</span>
<a name="l01557"></a>01557 <span class="comment">Add the files lodepng.c(pp) and lodepng.h to your project, include</span>
<a name="l01558"></a>01558 <span class="comment">lodepng.h where needed, and your program can read/write PNG files.</span>
<a name="l01559"></a>01559 <span class="comment"></span>
<a name="l01560"></a>01560 <span class="comment">Use optimization! For both the encoder and decoder, compiling with the best</span>
<a name="l01561"></a>01561 <span class="comment">optimizations makes a large difference.</span>
<a name="l01562"></a>01562 <span class="comment"></span>
<a name="l01563"></a>01563 <span class="comment">Make sure that LodePNG is compiled with the same compiler of the same version</span>
<a name="l01564"></a>01564 <span class="comment">and with the same settings as the rest of the program, or the interfaces with</span>
<a name="l01565"></a>01565 <span class="comment">std::vectors and std::strings in C++ can be incompatible resulting in bad things.</span>
<a name="l01566"></a>01566 <span class="comment"></span>
<a name="l01567"></a>01567 <span class="comment">CHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.</span>
<a name="l01568"></a>01568 <span class="comment"></span>
<a name="l01569"></a>01569 <span class="comment">*) gcc and g++</span>
<a name="l01570"></a>01570 <span class="comment"></span>
<a name="l01571"></a>01571 <span class="comment">LodePNG is developed in gcc so this compiler is natively supported. It gives no</span>
<a name="l01572"></a>01572 <span class="comment">warnings with compiler options &quot;-Wall -Wextra -pedantic -ansi&quot;, with gcc and g++</span>
<a name="l01573"></a>01573 <span class="comment">version 4.5.1 on Linux.</span>
<a name="l01574"></a>01574 <span class="comment"></span>
<a name="l01575"></a>01575 <span class="comment">*) Mingw and Bloodshed DevC++</span>
<a name="l01576"></a>01576 <span class="comment"></span>
<a name="l01577"></a>01577 <span class="comment">The Mingw compiler (a port of gcc) used by Bloodshed DevC++ for Windows is fully</span>
<a name="l01578"></a>01578 <span class="comment">supported by LodePNG.</span>
<a name="l01579"></a>01579 <span class="comment"></span>
<a name="l01580"></a>01580 <span class="comment">*) Visual Studio 2005 and Visual C++ 2005 Express Edition</span>
<a name="l01581"></a>01581 <span class="comment"></span>
<a name="l01582"></a>01582 <span class="comment">Versions 20070604 up to 20080107 have been tested on VS2005 and work. Visual</span>
<a name="l01583"></a>01583 <span class="comment">studio may give warnings about &#39;fopen&#39; being deprecated. A multiplatform library</span>
<a name="l01584"></a>01584 <span class="comment">can&#39;t support the proposed Visual Studio alternative however.</span>
<a name="l01585"></a>01585 <span class="comment"></span>
<a name="l01586"></a>01586 <span class="comment">If you&#39;re using LodePNG in VS2005 and don&#39;t want to see the deprecated warnings,</span>
<a name="l01587"></a>01587 <span class="comment">put this on top of lodepng.h before the inclusions: #define _CRT_SECURE_NO_DEPRECATE</span>
<a name="l01588"></a>01588 <span class="comment"></span>
<a name="l01589"></a>01589 <span class="comment">*) Visual Studio 6.0</span>
<a name="l01590"></a>01590 <span class="comment"></span>
<a name="l01591"></a>01591 <span class="comment">The C++ version of LodePNG was not supported by Visual Studio 6.0 because Visual</span>
<a name="l01592"></a>01592 <span class="comment">Studio 6.0 doesn&#39;t follow the C++ standard and implements it incorrectly.</span>
<a name="l01593"></a>01593 <span class="comment">The current C version of LodePNG has not been tested in VS6 but may work now.</span>
<a name="l01594"></a>01594 <span class="comment"></span>
<a name="l01595"></a>01595 <span class="comment">*) Comeau C/C++</span>
<a name="l01596"></a>01596 <span class="comment"></span>
<a name="l01597"></a>01597 <span class="comment">Vesion 20070107 compiles without problems on the Comeau C/C++ Online Test Drive</span>
<a name="l01598"></a>01598 <span class="comment">at http://www.comeaucomputing.com/tryitout in both C90 and C++ mode.</span>
<a name="l01599"></a>01599 <span class="comment"></span>
<a name="l01600"></a>01600 <span class="comment">*) Compilers on Macintosh</span>
<a name="l01601"></a>01601 <span class="comment"></span>
<a name="l01602"></a>01602 <span class="comment">LodePNG has been reported to work both with the gcc and LLVM for Macintosh, both</span>
<a name="l01603"></a>01603 <span class="comment">for C and C++.</span>
<a name="l01604"></a>01604 <span class="comment"></span>
<a name="l01605"></a>01605 <span class="comment">*) Other Compilers</span>
<a name="l01606"></a>01606 <span class="comment"></span>
<a name="l01607"></a>01607 <span class="comment">If you encounter problems on other compilers, I&#39;m happy to help out make LodePNG</span>
<a name="l01608"></a>01608 <span class="comment">support the compiler if it supports the ISO C90 and C++ standard well enough and</span>
<a name="l01609"></a>01609 <span class="comment">the required modification doesn&#39;t require using non standard or less good C/C++</span>
<a name="l01610"></a>01610 <span class="comment">code or headers.</span>
<a name="l01611"></a>01611 <span class="comment"></span>
<a name="l01612"></a>01612 <span class="comment"></span>
<a name="l01613"></a>01613 <span class="comment">10. examples</span>
<a name="l01614"></a>01614 <span class="comment">------------</span>
<a name="l01615"></a>01615 <span class="comment"></span>
<a name="l01616"></a>01616 <span class="comment">This decoder and encoder example show the most basic usage of LodePNG (using the</span>
<a name="l01617"></a>01617 <span class="comment">classes, not the simple functions, which would be trivial)</span>
<a name="l01618"></a>01618 <span class="comment"></span>
<a name="l01619"></a>01619 <span class="comment">More complex examples can be found in:</span>
<a name="l01620"></a>01620 <span class="comment">-lodepng_examples.c: 9 different examples in C, such as showing the image with SDL, ...</span>
<a name="l01621"></a>01621 <span class="comment">-lodepng_examples.cpp: the same examples in C++ using the C++ wrapper of LodePNG</span>
<a name="l01622"></a>01622 <span class="comment"></span>
<a name="l01623"></a>01623 <span class="comment">These files can be found on the LodePNG website or searched for on the internet.</span>
<a name="l01624"></a>01624 <span class="comment"></span>
<a name="l01625"></a>01625 <span class="comment">10.1. decoder C++ example</span>
<a name="l01626"></a>01626 <span class="comment">-------------------------</span>
<a name="l01627"></a>01627 <span class="comment"></span>
<a name="l01629"></a>01629 <span class="comment">#include &quot;lodepng.h&quot;</span>
<a name="l01630"></a>01630 <span class="comment">#include &lt;iostream&gt;</span>
<a name="l01631"></a>01631 <span class="comment"></span>
<a name="l01632"></a>01632 <span class="comment">int main(int argc, char *argv[])</span>
<a name="l01633"></a>01633 <span class="comment">{</span>
<a name="l01634"></a>01634 <span class="comment">  const char* filename = argc &gt; 1 ? argv[1] : &quot;test.png&quot;;</span>
<a name="l01635"></a>01635 <span class="comment">  </span>
<a name="l01636"></a>01636 <span class="comment">  //load and decode</span>
<a name="l01637"></a>01637 <span class="comment">  std::vector&lt;unsigned char&gt; buffer, image; //buffer will contain the PNG file, image will contain the raw pixels</span>
<a name="l01638"></a>01638 <span class="comment">  LodePNG::loadFile(buffer, filename); //load the image file with given filename</span>
<a name="l01639"></a>01639 <span class="comment">  LodePNG::Decoder decoder;</span>
<a name="l01640"></a>01640 <span class="comment">  decoder.decode(image, buffer.size() ? &amp;buffer[0] : 0, (unsigned)buffer.size()); //decode the png</span>
<a name="l01641"></a>01641 <span class="comment">  </span>
<a name="l01642"></a>01642 <span class="comment">  //if there&#39;s an error, display it</span>
<a name="l01643"></a>01643 <span class="comment">  if(decoder.hasError()) std::cout &lt;&lt; &quot;error &quot; &lt;&lt; decoder.getError() &lt;&lt; &quot;: &quot; &lt;&lt; LodePNG_error_text(decoder.getError()) &lt;&lt; std::endl;</span>
<a name="l01644"></a>01644 <span class="comment">  </span>
<a name="l01645"></a>01645 <span class="comment">  int width = decoder.getWidth(); //get the width in pixels</span>
<a name="l01646"></a>01646 <span class="comment">  int height = decoder.getHeight(); //get the height in pixels</span>
<a name="l01647"></a>01647 <span class="comment">  //the pixels are now in the vector &quot;image&quot;, 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...</span>
<a name="l01648"></a>01648 <span class="comment">}</span>
<a name="l01649"></a>01649 <span class="comment"></span>
<a name="l01650"></a>01650 <span class="comment">//alternative version using the &quot;simple&quot; function</span>
<a name="l01651"></a>01651 <span class="comment">int main(int argc, char *argv[])</span>
<a name="l01652"></a>01652 <span class="comment">{</span>
<a name="l01653"></a>01653 <span class="comment">  const char* filename = argc &gt; 1 ? argv[1] : &quot;test.png&quot;;</span>
<a name="l01654"></a>01654 <span class="comment">  </span>
<a name="l01655"></a>01655 <span class="comment">  //load and decode</span>
<a name="l01656"></a>01656 <span class="comment">  std::vector&lt;unsigned char&gt; image;</span>
<a name="l01657"></a>01657 <span class="comment">  unsigned width, height;</span>
<a name="l01658"></a>01658 <span class="comment">  unsigned error = LodePNG::decode(image, width, height, filename);</span>
<a name="l01659"></a>01659 <span class="comment">  </span>
<a name="l01660"></a>01660 <span class="comment">  //if there&#39;s an error, display it</span>
<a name="l01661"></a>01661 <span class="comment">  if(error != 0) std::cout &lt;&lt; &quot;error &quot; &lt;&lt; error &lt;&lt; &quot;: &quot; &lt;&lt; LodePNG_error_text(error) &lt;&lt; std::endl;</span>
<a name="l01662"></a>01662 <span class="comment">  </span>
<a name="l01663"></a>01663 <span class="comment">  //the pixels are now in the vector &quot;image&quot;, 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...</span>
<a name="l01664"></a>01664 <span class="comment">}</span>
<a name="l01666"></a>01666 <span class="comment"></span>
<a name="l01667"></a>01667 <span class="comment"></span>
<a name="l01668"></a>01668 <span class="comment">10.2. encoder C++ example</span>
<a name="l01669"></a>01669 <span class="comment">-------------------------</span>
<a name="l01670"></a>01670 <span class="comment"></span>
<a name="l01672"></a>01672 <span class="comment">#include &quot;lodepng.h&quot;</span>
<a name="l01673"></a>01673 <span class="comment">#include &lt;iostream&gt;</span>
<a name="l01674"></a>01674 <span class="comment"></span>
<a name="l01675"></a>01675 <span class="comment">//saves image to filename given as argument. Warning, this overwrites the file without warning!</span>
<a name="l01676"></a>01676 <span class="comment">int main(int argc, char *argv[])</span>
<a name="l01677"></a>01677 <span class="comment">{</span>
<a name="l01678"></a>01678 <span class="comment">  //check if user gave a filename</span>
<a name="l01679"></a>01679 <span class="comment">  if(argc &lt;= 1)</span>
<a name="l01680"></a>01680 <span class="comment">  {</span>
<a name="l01681"></a>01681 <span class="comment">    std::cout &lt;&lt; &quot;please provide a filename to save to\n&quot;;</span>
<a name="l01682"></a>01682 <span class="comment">    return 0;</span>
<a name="l01683"></a>01683 <span class="comment">  }</span>
<a name="l01684"></a>01684 <span class="comment">  </span>
<a name="l01685"></a>01685 <span class="comment">  //generate some image</span>
<a name="l01686"></a>01686 <span class="comment">  std::vector&lt;unsigned char&gt; image;</span>
<a name="l01687"></a>01687 <span class="comment">  image.resize(512 * 512 * 4);</span>
<a name="l01688"></a>01688 <span class="comment">  for(unsigned y = 0; y &lt; 512; y++)</span>
<a name="l01689"></a>01689 <span class="comment">  for(unsigned x = 0; x &lt; 512; x++)</span>
<a name="l01690"></a>01690 <span class="comment">  {</span>
<a name="l01691"></a>01691 <span class="comment">    image[4 * 512 * y + 4 * x + 0] = 255 * !(x &amp; y);</span>
<a name="l01692"></a>01692 <span class="comment">    image[4 * 512 * y + 4 * x + 1] = x ^ y;</span>
<a name="l01693"></a>01693 <span class="comment">    image[4 * 512 * y + 4 * x + 2] = x | y;</span>
<a name="l01694"></a>01694 <span class="comment">    image[4 * 512 * y + 4 * x + 3] = 255;</span>
<a name="l01695"></a>01695 <span class="comment">  }</span>
<a name="l01696"></a>01696 <span class="comment">  </span>
<a name="l01697"></a>01697 <span class="comment">  //encode and save, using the Encoder class</span>
<a name="l01698"></a>01698 <span class="comment">  std::vector&lt;unsigned char&gt; buffer;</span>
<a name="l01699"></a>01699 <span class="comment">  LodePNG::Encoder encoder;</span>
<a name="l01700"></a>01700 <span class="comment">  encoder.encode(buffer, image, 512, 512);</span>
<a name="l01701"></a>01701 <span class="comment">  LodePNG::saveFile(buffer, argv[1]);</span>
<a name="l01702"></a>01702 <span class="comment">  </span>
<a name="l01703"></a>01703 <span class="comment">  //the same as the 4 lines of code above, but in 1 call without the class:</span>
<a name="l01704"></a>01704 <span class="comment">  //LodePNG::encode(argv[1], image, 512, 512);</span>
<a name="l01705"></a>01705 <span class="comment">}</span>
<a name="l01707"></a>01707 <span class="comment"></span>
<a name="l01708"></a>01708 <span class="comment"></span>
<a name="l01709"></a>01709 <span class="comment">10.3. Decoder C example</span>
<a name="l01710"></a>01710 <span class="comment">-----------------------</span>
<a name="l01711"></a>01711 <span class="comment"></span>
<a name="l01712"></a>01712 <span class="comment">This example loads the PNG from a file into a pixel buffer in 1 function call</span>
<a name="l01713"></a>01713 <span class="comment"></span>
<a name="l01714"></a>01714 <span class="comment">#include &quot;lodepng.h&quot;</span>
<a name="l01715"></a>01715 <span class="comment"></span>
<a name="l01716"></a>01716 <span class="comment">int main(int argc, char *argv[])</span>
<a name="l01717"></a>01717 <span class="comment">{</span>
<a name="l01718"></a>01718 <span class="comment">  unsigned error;</span>
<a name="l01719"></a>01719 <span class="comment">  unsigned char* image;</span>
<a name="l01720"></a>01720 <span class="comment">  size_t width, height;</span>
<a name="l01721"></a>01721 <span class="comment">  </span>
<a name="l01722"></a>01722 <span class="comment">  if(argc &lt;= 1) return 0;</span>
<a name="l01723"></a>01723 <span class="comment">  </span>
<a name="l01724"></a>01724 <span class="comment">  error = LodePNG_decode32_file(&amp;image, &amp;width, &amp;height, filename);</span>
<a name="l01725"></a>01725 <span class="comment">  </span>
<a name="l01726"></a>01726 <span class="comment">  if(error != 0) printf(&quot;error %u: %s\n&quot;, error, LodePNG_error_text(error));</span>
<a name="l01727"></a>01727 <span class="comment">  </span>
<a name="l01728"></a>01728 <span class="comment">  //use image here</span>
<a name="l01729"></a>01729 <span class="comment">  </span>
<a name="l01730"></a>01730 <span class="comment">  free(image);</span>
<a name="l01731"></a>01731 <span class="comment">}</span>
<a name="l01732"></a>01732 <span class="comment"></span>
<a name="l01733"></a>01733 <span class="comment"></span>
<a name="l01734"></a>01734 <span class="comment">11. changes</span>
<a name="l01735"></a>01735 <span class="comment">-----------</span>
<a name="l01736"></a>01736 <span class="comment"></span>
<a name="l01737"></a>01737 <span class="comment">The version number of LodePNG is the date of the change given in the format</span>
<a name="l01738"></a>01738 <span class="comment">yyyymmdd.</span>
<a name="l01739"></a>01739 <span class="comment"></span>
<a name="l01740"></a>01740 <span class="comment">Some changes aren&#39;t backwards compatible. Those are indicated with a (!)</span>
<a name="l01741"></a>01741 <span class="comment">symbol.</span>
<a name="l01742"></a>01742 <span class="comment"></span>
<a name="l01743"></a>01743 <span class="comment">*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman</span>
<a name="l01744"></a>01744 <span class="comment">    to optimize long sequences of zeros.</span>
<a name="l01745"></a>01745 <span class="comment">*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and</span>
<a name="l01746"></a>01746 <span class="comment">    LodePNG_InfoColor_canHaveAlpha functions for convenience.</span>
<a name="l01747"></a>01747 <span class="comment">*) 7 nov 2010: added LodePNG_error_text function to get error code description.</span>
<a name="l01748"></a>01748 <span class="comment">*) 30 okt 2010: made decoding slightly faster</span>
<a name="l01749"></a>01749 <span class="comment">*) 26 okt 2010: (!) changed some C function and struct names (more consistent).</span>
<a name="l01750"></a>01750 <span class="comment">     Reorganized the documentation and the declaration order in the header.</span>
<a name="l01751"></a>01751 <span class="comment">*) 08 aug 2010: only changed some comments and external samples.</span>
<a name="l01752"></a>01752 <span class="comment">*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.</span>
<a name="l01753"></a>01753 <span class="comment">*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.</span>
<a name="l01754"></a>01754 <span class="comment">*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could</span>
<a name="l01755"></a>01755 <span class="comment">    read by ignoring the problem but windows apps couldn&#39;t.</span>
<a name="l01756"></a>01756 <span class="comment">*) 06 jun 2008: added more error checks for out of memory cases.</span>
<a name="l01757"></a>01757 <span class="comment">*) 26 apr 2008: added a few more checks here and there to ensure more safety.</span>
<a name="l01758"></a>01758 <span class="comment">*) 06 mar 2008: crash with encoding of strings fixed</span>
<a name="l01759"></a>01759 <span class="comment">*) 02 feb 2008: support for international text chunks added (iTXt)</span>
<a name="l01760"></a>01760 <span class="comment">*) 23 jan 2008: small cleanups, and #defines to divide code in sections</span>
<a name="l01761"></a>01761 <span class="comment">*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.</span>
<a name="l01762"></a>01762 <span class="comment">*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.</span>
<a name="l01763"></a>01763 <span class="comment">*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added</span>
<a name="l01764"></a>01764 <span class="comment">    Also vareous fixes, such as in the deflate and the padding bits code.</span>
<a name="l01765"></a>01765 <span class="comment">*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved</span>
<a name="l01766"></a>01766 <span class="comment">    filtering code of encoder.</span>
<a name="l01767"></a>01767 <span class="comment">*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A</span>
<a name="l01768"></a>01768 <span class="comment">    C++ wrapper around this provides an interface almost identical to before.</span>
<a name="l01769"></a>01769 <span class="comment">    Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code</span>
<a name="l01770"></a>01770 <span class="comment">    are together in these files but it works both for C and C++ compilers.</span>
<a name="l01771"></a>01771 <span class="comment">*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks</span>
<a name="l01772"></a>01772 <span class="comment">*) 30 aug 2007: bug fixed which makes this Borland C++ compatible</span>
<a name="l01773"></a>01773 <span class="comment">*) 09 aug 2007: some VS2005 warnings removed again</span>
<a name="l01774"></a>01774 <span class="comment">*) 21 jul 2007: deflate code placed in new namespace separate from zlib code</span>
<a name="l01775"></a>01775 <span class="comment">*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images</span>
<a name="l01776"></a>01776 <span class="comment">*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing</span>
<a name="l01777"></a>01777 <span class="comment">    invalid std::vector element [0] fixed, and level 3 and 4 warnings removed</span>
<a name="l01778"></a>01778 <span class="comment">*) 02 jun 2007: made the encoder add a tag with version by default</span>
<a name="l01779"></a>01779 <span class="comment">*) 27 may 2007: zlib and png code separated (but still in the same file),</span>
<a name="l01780"></a>01780 <span class="comment">    simple encoder/decoder functions added for more simple usage cases</span>
<a name="l01781"></a>01781 <span class="comment">*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),</span>
<a name="l01782"></a>01782 <span class="comment">    moved some examples from here to lodepng_examples.cpp</span>
<a name="l01783"></a>01783 <span class="comment">*) 12 may 2007: palette decoding bug fixed</span>
<a name="l01784"></a>01784 <span class="comment">*) 24 apr 2007: changed the license from BSD to the zlib license</span>
<a name="l01785"></a>01785 <span class="comment">*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.</span>
<a name="l01786"></a>01786 <span class="comment">*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding</span>
<a name="l01787"></a>01787 <span class="comment">    palettized PNG images. Plus little interface change with palette and texts.</span>
<a name="l01788"></a>01788 <span class="comment">*) 03 mar 2007: Made it encode dynamic Huffman shorter  with repeat codes.</span>
<a name="l01789"></a>01789 <span class="comment">    Fixed a bug where the end code of a block had length 0 in the Huffman tree.</span>
<a name="l01790"></a>01790 <span class="comment">*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented</span>
<a name="l01791"></a>01791 <span class="comment">    and supported by the encoder, resulting in smaller PNGs at the output.</span>
<a name="l01792"></a>01792 <span class="comment">*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.</span>
<a name="l01793"></a>01793 <span class="comment">*) 24 jan 2007: gave encoder an error interface. Added color conversion from any</span>
<a name="l01794"></a>01794 <span class="comment">    greyscale type to 8-bit greyscale with or without alpha.</span>
<a name="l01795"></a>01795 <span class="comment">*) 21 jan 2007: (!) Totally changed the interface. It allows more color types</span>
<a name="l01796"></a>01796 <span class="comment">    to convert to and is more uniform. See the manual for how it works now.</span>
<a name="l01797"></a>01797 <span class="comment">*) 07 jan 2007: Some cleanup &amp; fixes, and a few changes over the last days:</span>
<a name="l01798"></a>01798 <span class="comment">    encode/decode custom tEXt chunks, separate classes for zlib &amp; deflate, and</span>
<a name="l01799"></a>01799 <span class="comment">    at last made the decoder give errors for incorrect Adler32 or Crc.</span>
<a name="l01800"></a>01800 <span class="comment">*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.</span>
<a name="l01801"></a>01801 <span class="comment">*) 29 dec 2006: Added support for encoding images without alpha channel, and</span>
<a name="l01802"></a>01802 <span class="comment">    cleaned out code as well as making certain parts faster.</span>
<a name="l01803"></a>01803 <span class="comment">*) 28 dec 2006: Added &quot;Settings&quot; to the encoder.</span>
<a name="l01804"></a>01804 <span class="comment">*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.</span>
<a name="l01805"></a>01805 <span class="comment">    Removed some code duplication in the decoder. Fixed little bug in an example.</span>
<a name="l01806"></a>01806 <span class="comment">*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.</span>
<a name="l01807"></a>01807 <span class="comment">    Fixed a bug of the decoder with 16-bit per color.</span>
<a name="l01808"></a>01808 <span class="comment">*) 15 okt 2006: Changed documentation structure</span>
<a name="l01809"></a>01809 <span class="comment">*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the</span>
<a name="l01810"></a>01810 <span class="comment">    given image buffer, however for now it&#39;s not compressed.</span>
<a name="l01811"></a>01811 <span class="comment">*) 08 sep 2006: (!) Changed to interface with a Decoder class</span>
<a name="l01812"></a>01812 <span class="comment">*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different</span>
<a name="l01813"></a>01813 <span class="comment">    way. Renamed decodePNG to decodePNGGeneric.</span>
<a name="l01814"></a>01814 <span class="comment">*) 29 jul 2006: (!) Changed the interface: image info is now returned as a</span>
<a name="l01815"></a>01815 <span class="comment">    struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.</span>
<a name="l01816"></a>01816 <span class="comment">*) 28 jul 2006: Cleaned the code and added new error checks.</span>
<a name="l01817"></a>01817 <span class="comment">    Corrected terminology &quot;deflate&quot; into &quot;inflate&quot;.</span>
<a name="l01818"></a>01818 <span class="comment">*) 23 jun 2006: Added SDL example in the documentation in the header, this</span>
<a name="l01819"></a>01819 <span class="comment">    example allows easy debugging by displaying the PNG and its transparency.</span>
<a name="l01820"></a>01820 <span class="comment">*) 22 jun 2006: (!) Changed way to obtain error value. Added</span>
<a name="l01821"></a>01821 <span class="comment">    loadFile function for convenience. Made decodePNG32 faster.</span>
<a name="l01822"></a>01822 <span class="comment">*) 21 jun 2006: (!) Changed type of info vector to unsigned.</span>
<a name="l01823"></a>01823 <span class="comment">    Changed position of palette in info vector. Fixed an important bug that</span>
<a name="l01824"></a>01824 <span class="comment">    happened on PNGs with an uncompressed block.</span>
<a name="l01825"></a>01825 <span class="comment">*) 16 jun 2006: Internally changed unsigned into unsigned where</span>
<a name="l01826"></a>01826 <span class="comment">    needed, and performed some optimizations.</span>
<a name="l01827"></a>01827 <span class="comment">*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them</span>
<a name="l01828"></a>01828 <span class="comment">    in LodePNG namespace. Changed the order of the parameters. Rewrote the</span>
<a name="l01829"></a>01829 <span class="comment">    documentation in the header. Renamed files to lodepng.cpp and lodepng.h</span>
<a name="l01830"></a>01830 <span class="comment">*) 22 apr 2006: Optimized and improved some code</span>
<a name="l01831"></a>01831 <span class="comment">*) 07 sep 2005: (!) Changed to std::vector interface</span>
<a name="l01832"></a>01832 <span class="comment">*) 12 aug 2005: Initial release</span>
<a name="l01833"></a>01833 <span class="comment"></span>
<a name="l01834"></a>01834 <span class="comment"></span>
<a name="l01835"></a>01835 <span class="comment">12. contact information</span>
<a name="l01836"></a>01836 <span class="comment">-----------------------</span>
<a name="l01837"></a>01837 <span class="comment"></span>
<a name="l01838"></a>01838 <span class="comment">Feel free to contact me with suggestions, problems, comments, ... concerning</span>
<a name="l01839"></a>01839 <span class="comment">LodePNG. If you encounter a PNG image that doesn&#39;t work properly with this</span>
<a name="l01840"></a>01840 <span class="comment">decoder, feel free to send it and I&#39;ll use it to find and fix the problem.</span>
<a name="l01841"></a>01841 <span class="comment"></span>
<a name="l01842"></a>01842 <span class="comment">My email address is (puzzle the account and domain together with an @ symbol):</span>
<a name="l01843"></a>01843 <span class="comment">Domain: gmail dot com.</span>
<a name="l01844"></a>01844 <span class="comment">Account: lode dot vandevenne.</span>
<a name="l01845"></a>01845 <span class="comment"></span>
<a name="l01846"></a>01846 <span class="comment"></span>
<a name="l01847"></a>01847 <span class="comment">Copyright (c) 2005-2010 Lode Vandevenne</span>
<a name="l01848"></a>01848 <span class="comment">*/</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 25 2010 16:57:24 for Editor by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
